"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/imagekitio-next";
exports.ids = ["vendor-chunks/imagekitio-next"];
exports.modules = {

/***/ "(ssr)/./node_modules/imagekitio-next/dist/imagekit-next.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/imagekitio-next/dist/imagekit-next.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IKImage: () => (/* binding */ IKImage),\n/* harmony export */   IKUpload: () => (/* binding */ IKUpload),\n/* harmony export */   IKVideo: () => (/* binding */ IKVideo),\n/* harmony export */   ImageKitClient: () => (/* binding */ ImageKit),\n/* harmony export */   ImageKitContext: () => (/* binding */ ImageKitContext),\n/* harmony export */   ImageKitProvider: () => (/* binding */ ImageKitProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar version = \"3.0.2\";\n\nvar errorMessages = {\n  MANDATORY_INITIALIZATION_MISSING: {\n    message: \"Missing urlEndpoint during SDK initialization\",\n    help: \"\"\n  },\n  INVALID_TRANSFORMATION_POSITION: {\n    message: \"Invalid transformationPosition parameter\",\n    help: \"\"\n  },\n  PRIVATE_KEY_CLIENT_SIDE: {\n    message: \"privateKey should not be passed on the client side\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_DATA: {\n    message: \"Missing data for upload\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_FILE_PARAMETER: {\n    message: \"Missing file parameter for upload\",\n    help: \"\"\n  },\n  MISSING_UPLOAD_FILENAME_PARAMETER: {\n    message: \"Missing fileName parameter for upload\",\n    help: \"\"\n  },\n  MISSING_AUTHENTICATION_ENDPOINT: {\n    message: \"Missing authentication endpoint for upload\",\n    help: \"\"\n  },\n  MISSING_PUBLIC_KEY: {\n    message: \"Missing public key for upload\",\n    help: \"\"\n  },\n  AUTH_ENDPOINT_TIMEOUT: {\n    message: \"The authenticationEndpoint you provided timed out in 60 seconds\",\n    help: \"\"\n  },\n  AUTH_ENDPOINT_NETWORK_ERROR: {\n    message: \"Request to authenticationEndpoint failed due to network error\",\n    help: \"\"\n  },\n  AUTH_INVALID_RESPONSE: {\n    message: \"Invalid response from authenticationEndpoint. The SDK expects a JSON response with three fields i.e. signature, token and expire.\",\n    help: \"\"\n  },\n  UPLOAD_ENDPOINT_NETWORK_ERROR: {\n    message: \"Request to ImageKit upload endpoint failed due to network error\",\n    help: \"\"\n  },\n  INVALID_UPLOAD_OPTIONS: {\n    message: \"Invalid uploadOptions parameter\",\n    help: \"\"\n  },\n  MISSING_SIGNATURE: {\n    message: \"Missing signature for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  MISSING_TOKEN: {\n    message: \"Missing token for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  MISSING_EXPIRE: {\n    message: \"Missing expire for upload. The SDK expects token, signature and expire for authentication.\",\n    help: \"\"\n  },\n  INVALID_TRANSFORMATION: {\n    message: \"Invalid transformation parameter. Please include at least pre, post, or both.\",\n    help: \"\"\n  },\n  INVALID_PRE_TRANSFORMATION: {\n    message: \"Invalid pre transformation parameter.\",\n    help: \"\"\n  },\n  INVALID_POST_TRANSFORMATION: {\n    message: \"Invalid post transformation parameter.\",\n    help: \"\"\n  }\n};\n\nfunction respond (isError, response, callback) {\n  if (typeof callback == \"function\") {\n    if (isError) {\n      callback(response, null);\n    } else {\n      callback(null, response);\n    }\n  }\n}\n\nfunction getResponseHeaderMap(xhr) {\n  var headers = {};\n  var responseHeaders = xhr.getAllResponseHeaders();\n  if (Object.keys(responseHeaders).length) {\n    responseHeaders.trim().split(/[\\r\\n]+/).map(function (value) {\n      return value.split(/: /);\n    }).forEach(function (keyValue) {\n      headers[keyValue[0].trim()] = keyValue[1].trim();\n    });\n  }\n  return headers;\n}\nvar addResponseHeadersAndBody = function addResponseHeadersAndBody(body, xhr) {\n  var response = _objectSpread2({}, body);\n  var responseMetadata = {\n    statusCode: xhr.status,\n    headers: getResponseHeaderMap(xhr)\n  };\n  Object.defineProperty(response, \"$ResponseMetadata\", {\n    value: responseMetadata,\n    enumerable: false,\n    writable: false\n  });\n  return response;\n};\nvar request = function request(uploadFileXHR, formData, callback) {\n  uploadFile(uploadFileXHR, formData).then(function (result) {\n    return respond(false, result, callback);\n  }, function (ex) {\n    return respond(true, ex, callback);\n  });\n};\nvar uploadFile = function uploadFile(uploadFileXHR, formData) {\n  return new Promise(function (resolve, reject) {\n    uploadFileXHR.open('POST', 'https://upload.imagekit.io/api/v1/files/upload');\n    uploadFileXHR.onerror = function (e) {\n      return reject(errorMessages.UPLOAD_ENDPOINT_NETWORK_ERROR);\n    };\n    uploadFileXHR.onload = function () {\n      if (uploadFileXHR.status === 200) {\n        try {\n          var body = JSON.parse(uploadFileXHR.responseText);\n          var uploadResponse = addResponseHeadersAndBody(body, uploadFileXHR);\n          return resolve(uploadResponse);\n        } catch (ex) {\n          return reject(ex);\n        }\n      } else {\n        try {\n          var body = JSON.parse(uploadFileXHR.responseText);\n          var uploadError = addResponseHeadersAndBody(body, uploadFileXHR);\n          return reject(uploadError);\n        } catch (ex) {\n          return reject(ex);\n        }\n      }\n    };\n    uploadFileXHR.send(formData);\n  });\n};\n\nvar upload = function upload(xhr, uploadOptions, options, callback) {\n  if (!uploadOptions.file) {\n    respond(true, errorMessages.MISSING_UPLOAD_FILE_PARAMETER, callback);\n    return;\n  }\n  if (!uploadOptions.fileName) {\n    respond(true, errorMessages.MISSING_UPLOAD_FILENAME_PARAMETER, callback);\n    return;\n  }\n  if (!options.publicKey) {\n    respond(true, errorMessages.MISSING_PUBLIC_KEY, callback);\n    return;\n  }\n  if (!uploadOptions.token) {\n    respond(true, errorMessages.MISSING_TOKEN, callback);\n    return;\n  }\n  if (!uploadOptions.signature) {\n    respond(true, errorMessages.MISSING_SIGNATURE, callback);\n    return;\n  }\n  if (!uploadOptions.expire) {\n    respond(true, errorMessages.MISSING_EXPIRE, callback);\n    return;\n  }\n  if (uploadOptions.transformation) {\n    if (!(Object.keys(uploadOptions.transformation).includes(\"pre\") || Object.keys(uploadOptions.transformation).includes(\"post\"))) {\n      respond(true, errorMessages.INVALID_TRANSFORMATION, callback);\n      return;\n    }\n    if (Object.keys(uploadOptions.transformation).includes(\"pre\") && !uploadOptions.transformation.pre) {\n      respond(true, errorMessages.INVALID_PRE_TRANSFORMATION, callback);\n      return;\n    }\n    if (Object.keys(uploadOptions.transformation).includes(\"post\")) {\n      if (Array.isArray(uploadOptions.transformation.post)) {\n        var _iterator = _createForOfIteratorHelper(uploadOptions.transformation.post),\n            _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var transformation = _step.value;\n            if (transformation.type === \"abs\" && !(transformation.protocol || transformation.value)) {\n              respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n              return;\n            } else if (transformation.type === \"transformation\" && !transformation.value) {\n              respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n              return;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        respond(true, errorMessages.INVALID_POST_TRANSFORMATION, callback);\n        return;\n      }\n    }\n  }\n  var formData = new FormData();\n  var key;\n  for (key in uploadOptions) {\n    if (key) {\n      if (key === \"file\" && typeof uploadOptions.file != \"string\") {\n        formData.append('file', uploadOptions.file, String(uploadOptions.fileName));\n      } else if (key === \"tags\" && Array.isArray(uploadOptions.tags)) {\n        formData.append('tags', uploadOptions.tags.join(\",\"));\n      } else if (key === 'signature') {\n        formData.append(\"signature\", uploadOptions.signature);\n      } else if (key === 'expire') {\n        formData.append(\"expire\", String(uploadOptions.expire));\n      } else if (key === 'token') {\n        formData.append(\"token\", uploadOptions.token);\n      } else if (key === \"responseFields\" && Array.isArray(uploadOptions.responseFields)) {\n        formData.append('responseFields', uploadOptions.responseFields.join(\",\"));\n      } else if (key === \"extensions\" && Array.isArray(uploadOptions.extensions)) {\n        formData.append('extensions', JSON.stringify(uploadOptions.extensions));\n      } else if (key === \"customMetadata\" && _typeof(uploadOptions.customMetadata) === \"object\" && !Array.isArray(uploadOptions.customMetadata) && uploadOptions.customMetadata !== null) {\n        formData.append('customMetadata', JSON.stringify(uploadOptions.customMetadata));\n      } else if (key === \"transformation\" && _typeof(uploadOptions.transformation) === \"object\" && uploadOptions.transformation !== null) {\n        formData.append(key, JSON.stringify(uploadOptions.transformation));\n      } else if (key === 'checks' && uploadOptions.checks) {\n        formData.append(\"checks\", uploadOptions.checks);\n      } else if (uploadOptions[key] !== undefined) {\n        formData.append(key, String(uploadOptions[key]));\n      }\n    }\n  }\n  formData.append(\"publicKey\", options.publicKey);\n  request(xhr, formData, callback);\n};\n\nvar supportedTransforms = {\n  width: \"w\",\n  height: \"h\",\n  aspectRatio: \"ar\",\n  quality: \"q\",\n  crop: \"c\",\n  cropMode: \"cm\",\n  focus: \"fo\",\n  x: \"x\",\n  y: \"y\",\n  format: \"f\",\n  radius: \"r\",\n  background: \"bg\",\n  border: \"b\",\n  rotation: \"rt\",\n  rotate: \"rt\",\n  blur: \"bl\",\n  named: \"n\",\n  progressive: \"pr\",\n  lossless: \"lo\",\n  trim: \"t\",\n  metadata: \"md\",\n  colorProfile: \"cp\",\n  defaultImage: \"di\",\n  dpr: \"dpr\",\n  effectSharpen: \"e-sharpen\",\n  effectUSM: \"e-usm\",\n  effectContrast: \"e-contrast\",\n  effectGray: \"e-grayscale\",\n  original: \"orig\",\n  effectShadow: \"e-shadow\",\n  effectGradient: \"e-gradient\",\n  raw: \"raw\"\n};\n\nvar DEFAULT_TRANSFORMATION_POSITION = \"path\";\nvar QUERY_TRANSFORMATION_POSITION = \"query\";\nvar VALID_TRANSFORMATION_POSITIONS = [DEFAULT_TRANSFORMATION_POSITION, QUERY_TRANSFORMATION_POSITION];\nvar CHAIN_TRANSFORM_DELIMITER = \":\";\nvar TRANSFORM_DELIMITER = \",\";\nvar TRANSFORM_KEY_VALUE_DELIMITER = \"-\";\nvar transformationUtils = {\n  getDefault: function getDefault() {\n    return DEFAULT_TRANSFORMATION_POSITION;\n  },\n  addAsQueryParameter: function addAsQueryParameter(options) {\n    return options.transformationPosition === QUERY_TRANSFORMATION_POSITION;\n  },\n  validParameters: function validParameters(options) {\n    if (typeof options.transformationPosition == \"undefined\") return false;\n    return VALID_TRANSFORMATION_POSITIONS.indexOf(options.transformationPosition) != -1;\n  },\n  getTransformKey: function getTransformKey(transform) {\n    if (!transform) {\n      return \"\";\n    }\n    return supportedTransforms[transform] || supportedTransforms[transform.toLowerCase()] || \"\";\n  },\n  getChainTransformDelimiter: function getChainTransformDelimiter() {\n    return CHAIN_TRANSFORM_DELIMITER;\n  },\n  getTransformDelimiter: function getTransformDelimiter() {\n    return TRANSFORM_DELIMITER;\n  },\n  getTransformKeyValueDelimiter: function getTransformKeyValueDelimiter() {\n    return TRANSFORM_KEY_VALUE_DELIMITER;\n  }\n};\n\nvar TRANSFORMATION_PARAMETER = \"tr\";\nfunction removeTrailingSlash(str) {\n  if (typeof str == \"string\" && str[str.length - 1] == \"/\") {\n    str = str.substring(0, str.length - 1);\n  }\n  return str;\n}\nfunction removeLeadingSlash(str) {\n  if (typeof str == \"string\" && str[0] == \"/\") {\n    str = str.slice(1);\n  }\n  return str;\n}\nfunction pathJoin(parts, sep) {\n  var separator = sep || \"/\";\n  var replace = new RegExp(separator + \"{1,}\", \"g\");\n  return parts.join(separator).replace(replace, separator);\n}\nvar buildURL = function buildURL(opts) {\n  if (!opts.path && !opts.src) {\n    return \"\";\n  }\n  var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;\n  try {\n    if (opts.path) {\n      urlEndpointPattern = new URL(opts.urlEndpoint).pathname;\n      urlObj = new URL(pathJoin([opts.urlEndpoint.replace(urlEndpointPattern, \"\"), opts.path]));\n    } else {\n      urlObj = new URL(opts.src);\n      isSrcParameterUsedForURL = true;\n    }\n  } catch (e) {\n    console.error(e);\n    return \"\";\n  }\n  for (var i in opts.queryParameters) {\n    urlObj.searchParams.append(i, String(opts.queryParameters[i]));\n  }\n  var transformationString = constructTransformationString(opts.transformation);\n  if (transformationString && transformationString.length) {\n    if (transformationUtils.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {\n      urlObj.searchParams.append(TRANSFORMATION_PARAMETER, transformationString);\n    } else {\n      urlObj.pathname = pathJoin([TRANSFORMATION_PARAMETER + transformationUtils.getChainTransformDelimiter() + transformationString, urlObj.pathname]);\n    }\n  }\n  if (urlEndpointPattern) {\n    urlObj.pathname = pathJoin([urlEndpointPattern, urlObj.pathname]);\n  } else {\n    urlObj.pathname = pathJoin([urlObj.pathname]);\n  }\n  return urlObj.href;\n};\nfunction constructTransformationString(transformation) {\n  if (!Array.isArray(transformation)) {\n    return \"\";\n  }\n  var parsedTransforms = [];\n  for (var i = 0, l = transformation.length; i < l; i++) {\n    var parsedTransformStep = [];\n    for (var key in transformation[i]) {\n      if (transformation[i][key] === undefined || transformation[i][key] === null) continue;\n      var transformKey = transformationUtils.getTransformKey(key);\n      if (!transformKey) {\n        transformKey = key;\n      }\n      if (transformation[i][key] === \"-\") {\n        parsedTransformStep.push(transformKey);\n      } else if (key === \"raw\") {\n        parsedTransformStep.push(transformation[i][key]);\n      } else {\n        var value = transformation[i][key];\n        if (transformKey === \"di\") {\n          value = removeTrailingSlash(removeLeadingSlash(value || \"\"));\n          value = value.replace(/\\//g, \"@@\");\n        }\n        parsedTransformStep.push([transformKey, value].join(transformationUtils.getTransformKeyValueDelimiter()));\n      }\n    }\n    parsedTransforms.push(parsedTransformStep.join(transformationUtils.getTransformDelimiter()));\n  }\n  return parsedTransforms.join(transformationUtils.getChainTransformDelimiter());\n}\n\nvar url = function url(urlOpts, defaultOptions) {\n  return buildURL(_objectSpread2(_objectSpread2({}, defaultOptions), urlOpts));\n};\n\nfunction mandatoryParametersAvailable(options) {\n  return options.urlEndpoint;\n}\nvar promisify = function promisify(thisContext, fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === fn.length && typeof args[args.length - 1] !== \"undefined\") {\n      if (typeof args[args.length - 1] !== \"function\") {\n        throw new Error(\"Callback must be a function.\");\n      }\n      fn.call.apply(fn, [thisContext].concat(args));\n    } else {\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(err) {\n          if (err) {\n            return reject(err);\n          } else {\n            for (var _len2 = arguments.length, results = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              results[_key2 - 1] = arguments[_key2];\n            }\n            resolve(results.length > 1 ? results : results[0]);\n          }\n        };\n        args.pop();\n        args.push(callback);\n        fn.call.apply(fn, [thisContext].concat(args));\n      });\n    }\n  };\n};\nvar ImageKit = function () {\n  function ImageKit(opts) {\n    _classCallCheck(this, ImageKit);\n    _defineProperty(this, \"options\", {\n      sdkVersion: \"javascript-\".concat(version),\n      publicKey: \"\",\n      urlEndpoint: \"\",\n      transformationPosition: transformationUtils.getDefault()\n    });\n    this.options = _objectSpread2(_objectSpread2({}, this.options), opts || {});\n    if (!mandatoryParametersAvailable(this.options)) {\n      throw errorMessages.MANDATORY_INITIALIZATION_MISSING;\n    }\n    if (!transformationUtils.validParameters(this.options)) {\n      throw errorMessages.INVALID_TRANSFORMATION_POSITION;\n    }\n  }\n  _createClass(ImageKit, [{\n    key: \"url\",\n    value: function url$1(urlOptions) {\n      return url(urlOptions, this.options);\n    }\n  }, {\n    key: \"upload\",\n    value: function upload$1(uploadOptions, callbackOrOptions, options) {\n      var callback;\n      if (typeof callbackOrOptions === 'function') {\n        callback = callbackOrOptions;\n      } else {\n        options = callbackOrOptions || {};\n      }\n      if (!uploadOptions || _typeof(uploadOptions) !== \"object\") {\n        return respond(true, errorMessages.INVALID_UPLOAD_OPTIONS, callback);\n      }\n      var mergedOptions = _objectSpread2(_objectSpread2({}, this.options), options);\n      var _ref = uploadOptions || {},\n          userProvidedXHR = _ref.xhr;\n      delete uploadOptions.xhr;\n      var xhr = userProvidedXHR || new XMLHttpRequest();\n      return promisify(this, upload)(xhr, uploadOptions, mergedOptions, callback);\n    }\n  }]);\n  return ImageKit;\n}();\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n// Create the context\nconst ImageKitContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n/**\n * Provides a container for ImageKit components. Any option set in ImageKitProvider will be passed to the children.\n *\n * @example\n *<ImageKitProvider  publicKey=\"<public key>\" urlEndpoint=\"url link\">\n *    <!-- other tags -->\n *    <Image src={link}/>\n *</ImageKitProvider>\n */\nconst ImageKitProvider = props => {\n  const extractContextOptions = mergedOptions => {\n    const propKeys = [\"publicKey\", \"urlEndpoint\", \"authenticator\", \"transformationPosition\", \"ikClient\"];\n    for (const key in mergedOptions) {\n      if (!propKeys.includes(key)) {\n        delete mergedOptions[key];\n      }\n    }\n    return mergedOptions;\n  };\n  const mergedOptions = Object.assign({}, props);\n  const contextOptionsExtracted = extractContextOptions(mergedOptions);\n  if (contextOptionsExtracted.urlEndpoint && contextOptionsExtracted.urlEndpoint.trim() !== \"\") {\n    contextOptionsExtracted.ikClient = new ImageKit({\n      urlEndpoint: contextOptionsExtracted.urlEndpoint,\n      // @ts-ignore\n      sdkVersion: \"\"\n    });\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ImageKitContext.Provider, {\n    value: contextOptionsExtracted\n  }, props.children);\n};\n\nconst useImageKitComponent = props => {\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  const getIKClient = () => {\n    if (contextOptions && contextOptions.ikClient) {\n      return contextOptions.ikClient;\n    }\n    let {\n      urlEndpoint\n    } = props;\n    urlEndpoint = urlEndpoint || contextOptions && contextOptions.urlEndpoint;\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n      throw new Error(\"Missing urlEndpoint during initialization\");\n    }\n    const ikClient = new ImageKit({\n      urlEndpoint: urlEndpoint,\n      // @ts-ignore\n      sdkVersion: \"\"\n    });\n    return ikClient;\n  };\n  return {\n    getIKClient\n  };\n};\n\nconst fetchEffectiveConnection = () => {\n  try {\n    return navigator.connection.effectiveType;\n  } catch (ex) {\n    return \"4g\";\n  }\n};\nconst getSrc = ({\n  urlEndpoint,\n  lqip,\n  src,\n  path,\n  transformation,\n  transformationPosition,\n  queryParameters\n}, ikClient, contextOptions) => {\n  let options;\n  if (src) {\n    options = {\n      urlEndpoint: urlEndpoint || contextOptions.urlEndpoint,\n      src,\n      transformation: transformation || undefined,\n      transformationPosition: transformationPosition || contextOptions.transformationPosition || undefined,\n      queryParameters: queryParameters || {}\n    };\n  } else if (path) {\n    options = {\n      urlEndpoint: urlEndpoint || contextOptions.urlEndpoint,\n      path,\n      transformation: transformation || undefined,\n      transformationPosition: transformationPosition || contextOptions.transformationPosition || undefined,\n      queryParameters: queryParameters || {}\n    };\n  } else return {\n    originalSrc: \"\"\n  };\n  const result = {\n    originalSrc: ikClient.url(options)\n  };\n  if (lqip && lqip.active) {\n    var quality = Math.round(lqip.quality || lqip.threshold || 20);\n    var blur = Math.round(lqip.blur || 6);\n    var newTransformation = options.transformation ? [...options.transformation] : [];\n    if (lqip.raw && typeof lqip.raw === \"string\" && lqip.raw.trim() !== \"\") {\n      newTransformation.push({\n        raw: lqip.raw.trim()\n      });\n    } else {\n      newTransformation.push({\n        quality: String(quality),\n        blur: String(blur)\n      });\n    }\n    result.lqipSrc = ikClient.url(Object.assign(Object.assign({}, options), {\n      transformation: newTransformation\n    }));\n  }\n  return result;\n};\nconst getIKElementsUrl = ({\n  lqip = null,\n  loading\n}, {\n  intersected,\n  originalSrcLoaded,\n  originalSrc,\n  lqipSrc\n}) => {\n  /*\n      No lazy loading no lqip\n        src=originalImage\n      No lazy loading lqip\n        src=lqip\n        src=originalImage (when loaded)\n      lazy loading and no lqip\n        src=''\n        onIntersect:\n        src=originalImage\n      lazy loading and lqip\n        src=lqip\n        onIntersect:\n        src=originalImage (when loaded)\n    */\n  const isLqipActive = lqip => lqip && lqip.active;\n  if (loading !== \"lazy\" && !isLqipActive(lqip)) {\n    return originalSrc;\n  } else if (loading !== \"lazy\" && isLqipActive(lqip)) {\n    if (originalSrcLoaded) {\n      return originalSrc;\n    } else {\n      return lqipSrc;\n    }\n  } else if (loading === \"lazy\" && !isLqipActive(lqip)) {\n    if (intersected) {\n      return originalSrc;\n    } else {\n      return \"\";\n    }\n  } else {\n    if (intersected && originalSrcLoaded) {\n      return originalSrc;\n    } else {\n      return lqipSrc;\n    }\n  }\n};\nfunction hasProperty(array, property) {\n  return array.some(obj => obj.hasOwnProperty(property));\n}\nconst updateTransformation = ({\n  width,\n  height,\n  transformation,\n  src,\n  path,\n  quality\n}) => {\n  //if height and width are there in props and absent in transformation then add it to the transformatiion\n  if ((src || path) && (width || quality || height)) {\n    let transformationObject = {};\n    if (!((transformation === null || transformation === void 0 ? void 0 : transformation.length) && (hasProperty(transformation, \"height\") || hasProperty(transformation, \"width\")))) {\n      if (height) transformationObject[\"height\"] = String(height);\n      if (width) transformationObject[\"width\"] = String(width);\n    }\n    if (!((transformation === null || transformation === void 0 ? void 0 : transformation.length) && hasProperty(transformation, \"quality\")) && quality) transformationObject[\"quality\"] = String(quality);\n    if (Object.keys(transformationObject).length) {\n      if (transformation === null || transformation === void 0 ? void 0 : transformation.length) transformation = [...transformation, transformationObject];else transformation = [transformationObject];\n    }\n  }\n  return transformation;\n};\n\nconst IKImage = props => {\n  const [currentUrl, setCurrentUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n  const [imageProps, setImageProps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const [originalSrc, setOriginalSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  const [lqipSrc, setLqipSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  const [originalSrcLoaded, setOriginalSrcLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [observe, setObserve] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n  const [initialized, setInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [intersected, setIntersected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      originalSrc: newOriginalSrc,\n      lqipSrc: newLqipSrc\n    } = getSrc(Object.assign(Object.assign({}, props), {\n      transformation: updateTransformation(props)\n    }), getIKClient(), contextOptions);\n    setOriginalSrc(newOriginalSrc);\n    setLqipSrc(newLqipSrc ? newLqipSrc : \"\");\n    setInitialized(true);\n  }, [contextOptions, props]);\n  const updateImageUrl = () => __awaiter(void 0, void 0, void 0, function* () {\n    const url = yield getIKElementsUrl(props, {\n      originalSrc,\n      lqipSrc,\n      intersected,\n      contextOptions,\n      initialzeState: initialized,\n      originalSrcLoaded,\n      observe\n    }); // Include intersected state\n    if (url) {\n      setCurrentUrl(url);\n    }\n  });\n  const triggerOriginalImageLoad = () => {\n    var img = new Image();\n    img.onload = () => {\n      setOriginalSrcLoaded(true);\n    };\n    img.src = originalSrc;\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (originalSrcLoaded) updateImageUrl();\n  }, [originalSrcLoaded]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const image = imageRef.current;\n    const {\n      loading\n    } = props;\n    if (initialized) {\n      if (window && \"IntersectionObserver\" in window && loading === \"lazy\" && lqip) {\n        const connectionType = fetchEffectiveConnection();\n        let rootMargin = \"1250px\";\n        if (connectionType !== \"4g\") rootMargin = \"2500px\";\n        const imageObserver = new IntersectionObserver(entries => {\n          const el = entries[0];\n          if (el && el.isIntersecting && !intersected) {\n            setIntersected(true);\n            setObserve(prevObserver => {\n              if (prevObserver) {\n                prevObserver.disconnect();\n              }\n              return undefined;\n            });\n            triggerOriginalImageLoad();\n            updateImageUrl();\n          }\n        }, {\n          rootMargin: `${rootMargin} 0px ${rootMargin} 0px`\n        });\n        if (image) {\n          imageObserver.observe(image);\n          setObserve(imageObserver);\n        }\n      } else {\n        setIntersected(true);\n        triggerOriginalImageLoad();\n        updateImageUrl();\n      }\n    }\n    return () => {\n      if (observe) {\n        observe.disconnect();\n      }\n    };\n  }, [props, originalSrc, lqipSrc]);\n  const {\n      urlEndpoint,\n      authenticator,\n      publicKey,\n      loading,\n      lqip,\n      path,\n      src,\n      transformation,\n      transformationPosition,\n      queryParameters,\n      alt\n    } = props,\n    restProps = __rest(props, [\"urlEndpoint\", \"authenticator\", \"publicKey\", \"loading\", \"lqip\", \"path\", \"src\", \"transformation\", \"transformationPosition\", \"queryParameters\", \"alt\"]);\n  const restPropsWithoutImageProps = __rest(restProps, [\"fill\", \"quality\", \"priority\", \"placeholder\", \"blurDataURL\", \"unoptimized\", \"overrideSrc\", \"onLoadingComplete\", \"layout\", \"objectFit\", \"objectPosition\", \"lazyBoundary\", \"lazyRoot\"]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // if height and width are there in transformation skip props height and width and add fill =true\n    const updatedRestProps = restProps;\n    if ((transformation === null || transformation === void 0 ? void 0 : transformation.length) && transformation.some(obj => obj.hasOwnProperty(\"height\") || obj.hasOwnProperty(\"width\"))) {\n      if (updatedRestProps.height) delete updatedRestProps[\"height\"];\n      if (updatedRestProps.width) delete updatedRestProps[\"width\"];\n      updatedRestProps[\"fill\"] = true;\n    }\n    setImageProps(updatedRestProps);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (lqip === null || lqip === void 0 ? void 0 : lqip.active) console.warn(\"In [imagekitio-next], loading is set to eager when LQIP is used.\");\n  }, [lqip]);\n  return currentUrl != undefined && Object.keys(imageProps).length ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Object.assign({\n    loader: ({\n      src\n    }) => src,\n    alt: alt,\n    src: currentUrl ? currentUrl : \"\",\n    ref: imageRef,\n    unoptimized: true,\n    loading: (lqip === null || lqip === void 0 ? void 0 : lqip.active) ? \"eager\" : loading\n  }, imageProps)) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", Object.assign({\n    src: currentUrl ? currentUrl : undefined,\n    ref: imageRef\n  }, restPropsWithoutImageProps));\n};\n\nconst IKUpload = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const contextOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const abort = () => {\n      if (state.xhr) {\n        state.xhr.abort();\n      }\n    };\n    if (ref && typeof ref === \"object\" && ref.hasOwnProperty(\"current\")) {\n      const refObject = ref;\n      refObject.current.abort = abort;\n    }\n  }, [state.xhr, ref]);\n  const {\n      publicKey,\n      urlEndpoint,\n      authenticator,\n      fileName,\n      useUniqueFileName,\n      tags,\n      folder,\n      isPrivateFile,\n      customCoordinates,\n      responseFields,\n      onError,\n      onSuccess,\n      onUploadStart,\n      onUploadProgress,\n      validateFile,\n      webhookUrl,\n      overwriteFile,\n      overwriteAITags,\n      overwriteTags,\n      overwriteCustomMetadata,\n      extensions,\n      customMetadata,\n      transformation,\n      overrideParameters,\n      checks\n    } = props,\n    restProps = __rest(props, [\"publicKey\", \"urlEndpoint\", \"authenticator\", \"fileName\", \"useUniqueFileName\", \"tags\", \"folder\", \"isPrivateFile\", \"customCoordinates\", \"responseFields\", \"onError\", \"onSuccess\", \"onUploadStart\", \"onUploadProgress\", \"validateFile\", \"webhookUrl\", \"overwriteFile\", \"overwriteAITags\", \"overwriteTags\", \"overwriteCustomMetadata\", \"extensions\", \"customMetadata\", \"transformation\", \"overrideParameters\", \"checks\"]);\n  const uploadFile = e => {\n    var _a;\n    const publicKey = props.publicKey || contextOptions.publicKey;\n    const authenticator = props.authenticator || contextOptions.authenticator;\n    const urlEndpoint = props.urlEndpoint || contextOptions.urlEndpoint;\n    if (!publicKey || publicKey.trim() === \"\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"Missing publicKey\"\n        });\n      }\n      return;\n    }\n    if (!authenticator) {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The authenticator function is not provided.\"\n        });\n      }\n      return;\n    }\n    if (typeof authenticator !== \"function\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The provided authenticator is not a function.\"\n        });\n      }\n      return;\n    }\n    if (!urlEndpoint || urlEndpoint.trim() === \"\") {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"Missing urlEndpoint\"\n        });\n      }\n      return;\n    }\n    var ikClient = getIKClient();\n    const file = (_a = e.target.files) === null || _a === void 0 ? void 0 : _a[0];\n    if (!file) {\n      return;\n    }\n    if (props.validateFile && !props.validateFile(file)) {\n      return;\n    }\n    if (props.onUploadStart && typeof props.onUploadStart === \"function\") {\n      props.onUploadStart(e);\n    }\n    let overrideValues = {};\n    if (props.overrideParameters && typeof props.overrideParameters === \"function\") {\n      overrideValues = props.overrideParameters(file) || {};\n    }\n    const xhr = new XMLHttpRequest();\n    const progressCb = e => {\n      if (props.onUploadProgress && typeof props.onUploadProgress === \"function\") {\n        props.onUploadProgress(e);\n      }\n    };\n    xhr.upload.addEventListener(\"progress\", progressCb);\n    var params = {\n      file: file,\n      fileName: overrideValues.fileName || fileName || file.name,\n      useUniqueFileName: overrideValues.useUniqueFileName || useUniqueFileName,\n      tags: overrideValues.tags || tags,\n      folder: overrideValues.folder || folder,\n      isPrivateFile: overrideValues.isPrivateFile || isPrivateFile,\n      customCoordinates: overrideValues.customCoordinates || customCoordinates,\n      responseFields,\n      extensions: overrideValues.extensions || extensions,\n      webhookUrl: overrideValues.webhookUrl || webhookUrl,\n      overwriteFile: overrideValues.overwriteFile || overwriteFile,\n      overwriteAITags: overrideValues.overwriteAITags || overwriteAITags,\n      overwriteTags: overrideValues.overwriteTags || overwriteTags,\n      overwriteCustomMetadata: overrideValues.overwriteCustomMetadata || overwriteCustomMetadata,\n      customMetadata: overrideValues.customMetadata || customMetadata,\n      signature: \"\",\n      expire: 0,\n      token: \"\",\n      xhr,\n      transformation: overrideValues.transformation || transformation,\n      checks: overrideValues.checks || checks\n    };\n    const authPromise = authenticator();\n    if (!(authPromise instanceof Promise)) {\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: \"The authenticator function is expected to return a Promise instance.\"\n        });\n      }\n      return;\n    }\n    authPromise.then(({\n      signature,\n      token,\n      expire\n    }) => {\n      params[\"signature\"] = signature;\n      params[\"expire\"] = expire;\n      params[\"token\"] = token;\n      ikClient.upload(params, (err, result) => {\n        if (err) {\n          if (onError && typeof onError === \"function\") {\n            onError(err);\n          }\n        } else {\n          if (onSuccess && typeof onSuccess === \"function\") {\n            onSuccess(result);\n          }\n        }\n        xhr.upload.removeEventListener(\"progress\", progressCb);\n      }, {\n        publicKey\n      });\n      setState({\n        xhr\n      });\n    }).catch(data => {\n      var error;\n      if (data instanceof Array) {\n        error = data[0];\n      } else {\n        error = data;\n      }\n      if (onError && typeof onError === \"function\") {\n        onError({\n          message: String(error)\n        });\n      }\n      return;\n    });\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", Object.assign({}, restProps, {\n    ref: ref,\n    type: \"file\",\n    onChange: e => {\n      if (props.onChange && typeof props.onChange === \"function\") {\n        props.onChange(e);\n      }\n      uploadFile(e);\n    }\n  }));\n});\n\nconst IKVideo = props => {\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    currentUrl: \"\",\n    contextOptions: {}\n  });\n  const {\n    getIKClient\n  } = useImageKitComponent(Object.assign({}, props));\n  const contextItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ImageKitContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      originalSrc\n    } = getSrc(props, getIKClient(), contextItems);\n    setState(prevState => Object.assign(Object.assign({}, prevState), {\n      currentUrl: originalSrc,\n      contextOptions: contextItems\n    }));\n  }, [contextItems, props]);\n  const {\n    currentUrl\n  } = state;\n  const restProps = __rest(props, [\"urlEndpoint\", \"publicKey\", \"authenticator\", \"path\", \"src\", \"transformation\", \"transformationPosition\", \"queryParameters\"]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"video\", Object.assign({}, restProps, {\n    ref: videoRef,\n    key: currentUrl\n  }), react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"source\", {\n    src: currentUrl || undefined,\n    type: \"video/mp4\"\n  }));\n};\n\n\n//# sourceMappingURL=imagekit-next.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1hZ2VraXRpby1uZXh0L2Rpc3QvaW1hZ2VraXQtbmV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWtHO0FBQy9EOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtB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QUMzQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsMERBQW1CLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksdUNBQXVDO0FBQzNDLHVCQUF1QixpREFBVTtBQUNqQyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsMERBQW1CLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0EsR0FBRyxHQUFHLDBEQUFtQjtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVxRztBQUNyRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxTT1VNQURFRVBcXERvY3VtZW50c1xcR2l0SHViXFx2aXJlXFxub2RlX21vZHVsZXNcXGltYWdla2l0aW8tbmV4dFxcZGlzdFxcaW1hZ2VraXQtbmV4dC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBOZXh0SW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgICBkaWRFcnIgPSBmYWxzZSxcbiAgICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgIGVyciA9IGU7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuMC4yXCI7XG5cbnZhciBlcnJvck1lc3NhZ2VzID0ge1xuICBNQU5EQVRPUllfSU5JVElBTElaQVRJT05fTUlTU0lORzoge1xuICAgIG1lc3NhZ2U6IFwiTWlzc2luZyB1cmxFbmRwb2ludCBkdXJpbmcgU0RLIGluaXRpYWxpemF0aW9uXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBJTlZBTElEX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uUG9zaXRpb24gcGFyYW1ldGVyXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBQUklWQVRFX0tFWV9DTElFTlRfU0lERToge1xuICAgIG1lc3NhZ2U6IFwicHJpdmF0ZUtleSBzaG91bGQgbm90IGJlIHBhc3NlZCBvbiB0aGUgY2xpZW50IHNpZGVcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIE1JU1NJTkdfVVBMT0FEX0RBVEE6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZGF0YSBmb3IgdXBsb2FkXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX1VQTE9BRF9GSUxFX1BBUkFNRVRFUjoge1xuICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBmaWxlIHBhcmFtZXRlciBmb3IgdXBsb2FkXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX1VQTE9BRF9GSUxFTkFNRV9QQVJBTUVURVI6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZmlsZU5hbWUgcGFyYW1ldGVyIGZvciB1cGxvYWRcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIE1JU1NJTkdfQVVUSEVOVElDQVRJT05fRU5EUE9JTlQ6IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgYXV0aGVudGljYXRpb24gZW5kcG9pbnQgZm9yIHVwbG9hZFwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgTUlTU0lOR19QVUJMSUNfS0VZOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIHB1YmxpYyBrZXkgZm9yIHVwbG9hZFwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgQVVUSF9FTkRQT0lOVF9USU1FT1VUOiB7XG4gICAgbWVzc2FnZTogXCJUaGUgYXV0aGVudGljYXRpb25FbmRwb2ludCB5b3UgcHJvdmlkZWQgdGltZWQgb3V0IGluIDYwIHNlY29uZHNcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIEFVVEhfRU5EUE9JTlRfTkVUV09SS19FUlJPUjoge1xuICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCB0byBhdXRoZW50aWNhdGlvbkVuZHBvaW50IGZhaWxlZCBkdWUgdG8gbmV0d29yayBlcnJvclwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgQVVUSF9JTlZBTElEX1JFU1BPTlNFOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gYXV0aGVudGljYXRpb25FbmRwb2ludC4gVGhlIFNESyBleHBlY3RzIGEgSlNPTiByZXNwb25zZSB3aXRoIHRocmVlIGZpZWxkcyBpLmUuIHNpZ25hdHVyZSwgdG9rZW4gYW5kIGV4cGlyZS5cIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIFVQTE9BRF9FTkRQT0lOVF9ORVRXT1JLX0VSUk9SOiB7XG4gICAgbWVzc2FnZTogXCJSZXF1ZXN0IHRvIEltYWdlS2l0IHVwbG9hZCBlbmRwb2ludCBmYWlsZWQgZHVlIHRvIG5ldHdvcmsgZXJyb3JcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIElOVkFMSURfVVBMT0FEX09QVElPTlM6IHtcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgdXBsb2FkT3B0aW9ucyBwYXJhbWV0ZXJcIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIE1JU1NJTkdfU0lHTkFUVVJFOiB7XG4gICAgbWVzc2FnZTogXCJNaXNzaW5nIHNpZ25hdHVyZSBmb3IgdXBsb2FkLiBUaGUgU0RLIGV4cGVjdHMgdG9rZW4sIHNpZ25hdHVyZSBhbmQgZXhwaXJlIGZvciBhdXRoZW50aWNhdGlvbi5cIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIE1JU1NJTkdfVE9LRU46IHtcbiAgICBtZXNzYWdlOiBcIk1pc3NpbmcgdG9rZW4gZm9yIHVwbG9hZC4gVGhlIFNESyBleHBlY3RzIHRva2VuLCBzaWduYXR1cmUgYW5kIGV4cGlyZSBmb3IgYXV0aGVudGljYXRpb24uXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBNSVNTSU5HX0VYUElSRToge1xuICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBpcmUgZm9yIHVwbG9hZC4gVGhlIFNESyBleHBlY3RzIHRva2VuLCBzaWduYXR1cmUgYW5kIGV4cGlyZSBmb3IgYXV0aGVudGljYXRpb24uXCIsXG4gICAgaGVscDogXCJcIlxuICB9LFxuICBJTlZBTElEX1RSQU5TRk9STUFUSU9OOiB7XG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlci4gUGxlYXNlIGluY2x1ZGUgYXQgbGVhc3QgcHJlLCBwb3N0LCBvciBib3RoLlwiLFxuICAgIGhlbHA6IFwiXCJcbiAgfSxcbiAgSU5WQUxJRF9QUkVfVFJBTlNGT1JNQVRJT046IHtcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgcHJlIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlci5cIixcbiAgICBoZWxwOiBcIlwiXG4gIH0sXG4gIElOVkFMSURfUE9TVF9UUkFOU0ZPUk1BVElPTjoge1xuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBwb3N0IHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlci5cIixcbiAgICBoZWxwOiBcIlwiXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc3BvbmQgKGlzRXJyb3IsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXJNYXAoeGhyKSB7XG4gIHZhciBoZWFkZXJzID0ge307XG4gIHZhciByZXNwb25zZUhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG4gIGlmIChPYmplY3Qua2V5cyhyZXNwb25zZUhlYWRlcnMpLmxlbmd0aCkge1xuICAgIHJlc3BvbnNlSGVhZGVycy50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvOiAvKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlWYWx1ZSkge1xuICAgICAgaGVhZGVyc1trZXlWYWx1ZVswXS50cmltKCldID0ga2V5VmFsdWVbMV0udHJpbSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxudmFyIGFkZFJlc3BvbnNlSGVhZGVyc0FuZEJvZHkgPSBmdW5jdGlvbiBhZGRSZXNwb25zZUhlYWRlcnNBbmRCb2R5KGJvZHksIHhocikge1xuICB2YXIgcmVzcG9uc2UgPSBfb2JqZWN0U3ByZWFkMih7fSwgYm9keSk7XG4gIHZhciByZXNwb25zZU1ldGFkYXRhID0ge1xuICAgIHN0YXR1c0NvZGU6IHhoci5zdGF0dXMsXG4gICAgaGVhZGVyczogZ2V0UmVzcG9uc2VIZWFkZXJNYXAoeGhyKVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsIFwiJFJlc3BvbnNlTWV0YWRhdGFcIiwge1xuICAgIHZhbHVlOiByZXNwb25zZU1ldGFkYXRhLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciByZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCh1cGxvYWRGaWxlWEhSLCBmb3JtRGF0YSwgY2FsbGJhY2spIHtcbiAgdXBsb2FkRmlsZSh1cGxvYWRGaWxlWEhSLCBmb3JtRGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3BvbmQoZmFsc2UsIHJlc3VsdCwgY2FsbGJhY2spO1xuICB9LCBmdW5jdGlvbiAoZXgpIHtcbiAgICByZXR1cm4gcmVzcG9uZCh0cnVlLCBleCwgY2FsbGJhY2spO1xuICB9KTtcbn07XG52YXIgdXBsb2FkRmlsZSA9IGZ1bmN0aW9uIHVwbG9hZEZpbGUodXBsb2FkRmlsZVhIUiwgZm9ybURhdGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB1cGxvYWRGaWxlWEhSLm9wZW4oJ1BPU1QnLCAnaHR0cHM6Ly91cGxvYWQuaW1hZ2VraXQuaW8vYXBpL3YxL2ZpbGVzL3VwbG9hZCcpO1xuICAgIHVwbG9hZEZpbGVYSFIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycm9yTWVzc2FnZXMuVVBMT0FEX0VORFBPSU5UX05FVFdPUktfRVJST1IpO1xuICAgIH07XG4gICAgdXBsb2FkRmlsZVhIUi5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodXBsb2FkRmlsZVhIUi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZSh1cGxvYWRGaWxlWEhSLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgdmFyIHVwbG9hZFJlc3BvbnNlID0gYWRkUmVzcG9uc2VIZWFkZXJzQW5kQm9keShib2R5LCB1cGxvYWRGaWxlWEhSKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1cGxvYWRSZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJvZHkgPSBKU09OLnBhcnNlKHVwbG9hZEZpbGVYSFIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB2YXIgdXBsb2FkRXJyb3IgPSBhZGRSZXNwb25zZUhlYWRlcnNBbmRCb2R5KGJvZHksIHVwbG9hZEZpbGVYSFIpO1xuICAgICAgICAgIHJldHVybiByZWplY3QodXBsb2FkRXJyb3IpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGxvYWRGaWxlWEhSLnNlbmQoZm9ybURhdGEpO1xuICB9KTtcbn07XG5cbnZhciB1cGxvYWQgPSBmdW5jdGlvbiB1cGxvYWQoeGhyLCB1cGxvYWRPcHRpb25zLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoIXVwbG9hZE9wdGlvbnMuZmlsZSkge1xuICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5NSVNTSU5HX1VQTE9BRF9GSUxFX1BBUkFNRVRFUiwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXVwbG9hZE9wdGlvbnMuZmlsZU5hbWUpIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19VUExPQURfRklMRU5BTUVfUEFSQU1FVEVSLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghb3B0aW9ucy5wdWJsaWNLZXkpIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19QVUJMSUNfS0VZLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdXBsb2FkT3B0aW9ucy50b2tlbikge1xuICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5NSVNTSU5HX1RPS0VOLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdXBsb2FkT3B0aW9ucy5zaWduYXR1cmUpIHtcbiAgICByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuTUlTU0lOR19TSUdOQVRVUkUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF1cGxvYWRPcHRpb25zLmV4cGlyZSkge1xuICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5NSVNTSU5HX0VYUElSRSwgY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbikge1xuICAgIGlmICghKE9iamVjdC5rZXlzKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pLmluY2x1ZGVzKFwicHJlXCIpIHx8IE9iamVjdC5rZXlzKHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pLmluY2x1ZGVzKFwicG9zdFwiKSkpIHtcbiAgICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5JTlZBTElEX1RSQU5TRk9STUFUSU9OLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKS5pbmNsdWRlcyhcInByZVwiKSAmJiAhdXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wcmUpIHtcbiAgICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BSRV9UUkFOU0ZPUk1BVElPTiwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXBsb2FkT3B0aW9ucy50cmFuc2Zvcm1hdGlvbikuaW5jbHVkZXMoXCJwb3N0XCIpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uLnBvc3QpKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uLnBvc3QpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uLnR5cGUgPT09IFwiYWJzXCIgJiYgISh0cmFuc2Zvcm1hdGlvbi5wcm90b2NvbCB8fCB0cmFuc2Zvcm1hdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLklOVkFMSURfUE9TVF9UUkFOU0ZPUk1BVElPTiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybWF0aW9uLnR5cGUgPT09IFwidHJhbnNmb3JtYXRpb25cIiAmJiAhdHJhbnNmb3JtYXRpb24udmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzcG9uZCh0cnVlLCBlcnJvck1lc3NhZ2VzLklOVkFMSURfUE9TVF9UUkFOU0ZPUk1BVElPTiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbmQodHJ1ZSwgZXJyb3JNZXNzYWdlcy5JTlZBTElEX1BPU1RfVFJBTlNGT1JNQVRJT04sIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gdXBsb2FkT3B0aW9ucykge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZmlsZVwiICYmIHR5cGVvZiB1cGxvYWRPcHRpb25zLmZpbGUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCB1cGxvYWRPcHRpb25zLmZpbGUsIFN0cmluZyh1cGxvYWRPcHRpb25zLmZpbGVOYW1lKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ0YWdzXCIgJiYgQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLnRhZ3MpKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgndGFncycsIHVwbG9hZE9wdGlvbnMudGFncy5qb2luKFwiLFwiKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NpZ25hdHVyZScpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwic2lnbmF0dXJlXCIsIHVwbG9hZE9wdGlvbnMuc2lnbmF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhwaXJlJykge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJleHBpcmVcIiwgU3RyaW5nKHVwbG9hZE9wdGlvbnMuZXhwaXJlKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3Rva2VuJykge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJ0b2tlblwiLCB1cGxvYWRPcHRpb25zLnRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJlc3BvbnNlRmllbGRzXCIgJiYgQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLnJlc3BvbnNlRmllbGRzKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3Jlc3BvbnNlRmllbGRzJywgdXBsb2FkT3B0aW9ucy5yZXNwb25zZUZpZWxkcy5qb2luKFwiLFwiKSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJleHRlbnNpb25zXCIgJiYgQXJyYXkuaXNBcnJheSh1cGxvYWRPcHRpb25zLmV4dGVuc2lvbnMpKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZXh0ZW5zaW9ucycsIEpTT04uc3RyaW5naWZ5KHVwbG9hZE9wdGlvbnMuZXh0ZW5zaW9ucykpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiY3VzdG9tTWV0YWRhdGFcIiAmJiBfdHlwZW9mKHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEpICYmIHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdjdXN0b21NZXRhZGF0YScsIEpTT04uc3RyaW5naWZ5KHVwbG9hZE9wdGlvbnMuY3VzdG9tTWV0YWRhdGEpKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInRyYW5zZm9ybWF0aW9uXCIgJiYgX3R5cGVvZih1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiB1cGxvYWRPcHRpb25zLnRyYW5zZm9ybWF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIEpTT04uc3RyaW5naWZ5KHVwbG9hZE9wdGlvbnMudHJhbnNmb3JtYXRpb24pKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2hlY2tzJyAmJiB1cGxvYWRPcHRpb25zLmNoZWNrcykge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJjaGVja3NcIiwgdXBsb2FkT3B0aW9ucy5jaGVja3MpO1xuICAgICAgfSBlbHNlIGlmICh1cGxvYWRPcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCBTdHJpbmcodXBsb2FkT3B0aW9uc1trZXldKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvcm1EYXRhLmFwcGVuZChcInB1YmxpY0tleVwiLCBvcHRpb25zLnB1YmxpY0tleSk7XG4gIHJlcXVlc3QoeGhyLCBmb3JtRGF0YSwgY2FsbGJhY2spO1xufTtcblxudmFyIHN1cHBvcnRlZFRyYW5zZm9ybXMgPSB7XG4gIHdpZHRoOiBcIndcIixcbiAgaGVpZ2h0OiBcImhcIixcbiAgYXNwZWN0UmF0aW86IFwiYXJcIixcbiAgcXVhbGl0eTogXCJxXCIsXG4gIGNyb3A6IFwiY1wiLFxuICBjcm9wTW9kZTogXCJjbVwiLFxuICBmb2N1czogXCJmb1wiLFxuICB4OiBcInhcIixcbiAgeTogXCJ5XCIsXG4gIGZvcm1hdDogXCJmXCIsXG4gIHJhZGl1czogXCJyXCIsXG4gIGJhY2tncm91bmQ6IFwiYmdcIixcbiAgYm9yZGVyOiBcImJcIixcbiAgcm90YXRpb246IFwicnRcIixcbiAgcm90YXRlOiBcInJ0XCIsXG4gIGJsdXI6IFwiYmxcIixcbiAgbmFtZWQ6IFwiblwiLFxuICBwcm9ncmVzc2l2ZTogXCJwclwiLFxuICBsb3NzbGVzczogXCJsb1wiLFxuICB0cmltOiBcInRcIixcbiAgbWV0YWRhdGE6IFwibWRcIixcbiAgY29sb3JQcm9maWxlOiBcImNwXCIsXG4gIGRlZmF1bHRJbWFnZTogXCJkaVwiLFxuICBkcHI6IFwiZHByXCIsXG4gIGVmZmVjdFNoYXJwZW46IFwiZS1zaGFycGVuXCIsXG4gIGVmZmVjdFVTTTogXCJlLXVzbVwiLFxuICBlZmZlY3RDb250cmFzdDogXCJlLWNvbnRyYXN0XCIsXG4gIGVmZmVjdEdyYXk6IFwiZS1ncmF5c2NhbGVcIixcbiAgb3JpZ2luYWw6IFwib3JpZ1wiLFxuICBlZmZlY3RTaGFkb3c6IFwiZS1zaGFkb3dcIixcbiAgZWZmZWN0R3JhZGllbnQ6IFwiZS1ncmFkaWVudFwiLFxuICByYXc6IFwicmF3XCJcbn07XG5cbnZhciBERUZBVUxUX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OID0gXCJwYXRoXCI7XG52YXIgUVVFUllfVFJBTlNGT1JNQVRJT05fUE9TSVRJT04gPSBcInF1ZXJ5XCI7XG52YXIgVkFMSURfVFJBTlNGT1JNQVRJT05fUE9TSVRJT05TID0gW0RFRkFVTFRfVFJBTlNGT1JNQVRJT05fUE9TSVRJT04sIFFVRVJZX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OXTtcbnZhciBDSEFJTl9UUkFOU0ZPUk1fREVMSU1JVEVSID0gXCI6XCI7XG52YXIgVFJBTlNGT1JNX0RFTElNSVRFUiA9IFwiLFwiO1xudmFyIFRSQU5TRk9STV9LRVlfVkFMVUVfREVMSU1JVEVSID0gXCItXCI7XG52YXIgdHJhbnNmb3JtYXRpb25VdGlscyA9IHtcbiAgZ2V0RGVmYXVsdDogZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHtcbiAgICByZXR1cm4gREVGQVVMVF9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTjtcbiAgfSxcbiAgYWRkQXNRdWVyeVBhcmFtZXRlcjogZnVuY3Rpb24gYWRkQXNRdWVyeVBhcmFtZXRlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbiA9PT0gUVVFUllfVFJBTlNGT1JNQVRJT05fUE9TSVRJT047XG4gIH0sXG4gIHZhbGlkUGFyYW1ldGVyczogZnVuY3Rpb24gdmFsaWRQYXJhbWV0ZXJzKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbiA9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIFZBTElEX1RSQU5TRk9STUFUSU9OX1BPU0lUSU9OUy5pbmRleE9mKG9wdGlvbnMudHJhbnNmb3JtYXRpb25Qb3NpdGlvbikgIT0gLTE7XG4gIH0sXG4gIGdldFRyYW5zZm9ybUtleTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtS2V5KHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZFRyYW5zZm9ybXNbdHJhbnNmb3JtXSB8fCBzdXBwb3J0ZWRUcmFuc2Zvcm1zW3RyYW5zZm9ybS50b0xvd2VyQ2FzZSgpXSB8fCBcIlwiO1xuICB9LFxuICBnZXRDaGFpblRyYW5zZm9ybURlbGltaXRlcjogZnVuY3Rpb24gZ2V0Q2hhaW5UcmFuc2Zvcm1EZWxpbWl0ZXIoKSB7XG4gICAgcmV0dXJuIENIQUlOX1RSQU5TRk9STV9ERUxJTUlURVI7XG4gIH0sXG4gIGdldFRyYW5zZm9ybURlbGltaXRlcjogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRGVsaW1pdGVyKCkge1xuICAgIHJldHVybiBUUkFOU0ZPUk1fREVMSU1JVEVSO1xuICB9LFxuICBnZXRUcmFuc2Zvcm1LZXlWYWx1ZURlbGltaXRlcjogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtS2V5VmFsdWVEZWxpbWl0ZXIoKSB7XG4gICAgcmV0dXJuIFRSQU5TRk9STV9LRVlfVkFMVUVfREVMSU1JVEVSO1xuICB9XG59O1xuXG52YXIgVFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSID0gXCJ0clwiO1xuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09IFwiL1wiKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxlYWRpbmdTbGFzaChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIiAmJiBzdHJbMF0gPT0gXCIvXCIpIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHBhdGhKb2luKHBhcnRzLCBzZXApIHtcbiAgdmFyIHNlcGFyYXRvciA9IHNlcCB8fCBcIi9cIjtcbiAgdmFyIHJlcGxhY2UgPSBuZXcgUmVnRXhwKHNlcGFyYXRvciArIFwiezEsfVwiLCBcImdcIik7XG4gIHJldHVybiBwYXJ0cy5qb2luKHNlcGFyYXRvcikucmVwbGFjZShyZXBsYWNlLCBzZXBhcmF0b3IpO1xufVxudmFyIGJ1aWxkVVJMID0gZnVuY3Rpb24gYnVpbGRVUkwob3B0cykge1xuICBpZiAoIW9wdHMucGF0aCAmJiAhb3B0cy5zcmMpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB2YXIgdXJsT2JqLCBpc1NyY1BhcmFtZXRlclVzZWRGb3JVUkwsIHVybEVuZHBvaW50UGF0dGVybjtcbiAgdHJ5IHtcbiAgICBpZiAob3B0cy5wYXRoKSB7XG4gICAgICB1cmxFbmRwb2ludFBhdHRlcm4gPSBuZXcgVVJMKG9wdHMudXJsRW5kcG9pbnQpLnBhdGhuYW1lO1xuICAgICAgdXJsT2JqID0gbmV3IFVSTChwYXRoSm9pbihbb3B0cy51cmxFbmRwb2ludC5yZXBsYWNlKHVybEVuZHBvaW50UGF0dGVybiwgXCJcIiksIG9wdHMucGF0aF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsT2JqID0gbmV3IFVSTChvcHRzLnNyYyk7XG4gICAgICBpc1NyY1BhcmFtZXRlclVzZWRGb3JVUkwgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZm9yICh2YXIgaSBpbiBvcHRzLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuYXBwZW5kKGksIFN0cmluZyhvcHRzLnF1ZXJ5UGFyYW1ldGVyc1tpXSkpO1xuICB9XG4gIHZhciB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGNvbnN0cnVjdFRyYW5zZm9ybWF0aW9uU3RyaW5nKG9wdHMudHJhbnNmb3JtYXRpb24pO1xuICBpZiAodHJhbnNmb3JtYXRpb25TdHJpbmcgJiYgdHJhbnNmb3JtYXRpb25TdHJpbmcubGVuZ3RoKSB7XG4gICAgaWYgKHRyYW5zZm9ybWF0aW9uVXRpbHMuYWRkQXNRdWVyeVBhcmFtZXRlcihvcHRzKSB8fCBpc1NyY1BhcmFtZXRlclVzZWRGb3JVUkwpIHtcbiAgICAgIHVybE9iai5zZWFyY2hQYXJhbXMuYXBwZW5kKFRSQU5TRk9STUFUSU9OX1BBUkFNRVRFUiwgdHJhbnNmb3JtYXRpb25TdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmxPYmoucGF0aG5hbWUgPSBwYXRoSm9pbihbVFJBTlNGT1JNQVRJT05fUEFSQU1FVEVSICsgdHJhbnNmb3JtYXRpb25VdGlscy5nZXRDaGFpblRyYW5zZm9ybURlbGltaXRlcigpICsgdHJhbnNmb3JtYXRpb25TdHJpbmcsIHVybE9iai5wYXRobmFtZV0pO1xuICAgIH1cbiAgfVxuICBpZiAodXJsRW5kcG9pbnRQYXR0ZXJuKSB7XG4gICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aEpvaW4oW3VybEVuZHBvaW50UGF0dGVybiwgdXJsT2JqLnBhdGhuYW1lXSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsT2JqLnBhdGhuYW1lID0gcGF0aEpvaW4oW3VybE9iai5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiB1cmxPYmouaHJlZjtcbn07XG5mdW5jdGlvbiBjb25zdHJ1Y3RUcmFuc2Zvcm1hdGlvblN0cmluZyh0cmFuc2Zvcm1hdGlvbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodHJhbnNmb3JtYXRpb24pKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgdmFyIHBhcnNlZFRyYW5zZm9ybXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1hdGlvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkVHJhbnNmb3JtU3RlcCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2Zvcm1hdGlvbltpXSkge1xuICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uW2ldW2tleV0gPT09IHVuZGVmaW5lZCB8fCB0cmFuc2Zvcm1hdGlvbltpXVtrZXldID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHZhciB0cmFuc2Zvcm1LZXkgPSB0cmFuc2Zvcm1hdGlvblV0aWxzLmdldFRyYW5zZm9ybUtleShrZXkpO1xuICAgICAgaWYgKCF0cmFuc2Zvcm1LZXkpIHtcbiAgICAgICAgdHJhbnNmb3JtS2V5ID0ga2V5O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uW2ldW2tleV0gPT09IFwiLVwiKSB7XG4gICAgICAgIHBhcnNlZFRyYW5zZm9ybVN0ZXAucHVzaCh0cmFuc2Zvcm1LZXkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmF3XCIpIHtcbiAgICAgICAgcGFyc2VkVHJhbnNmb3JtU3RlcC5wdXNoKHRyYW5zZm9ybWF0aW9uW2ldW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtYXRpb25baV1ba2V5XTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybUtleSA9PT0gXCJkaVwiKSB7XG4gICAgICAgICAgdmFsdWUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHJlbW92ZUxlYWRpbmdTbGFzaCh2YWx1ZSB8fCBcIlwiKSk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC8vZywgXCJAQFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWRUcmFuc2Zvcm1TdGVwLnB1c2goW3RyYW5zZm9ybUtleSwgdmFsdWVdLmpvaW4odHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1LZXlWYWx1ZURlbGltaXRlcigpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlZFRyYW5zZm9ybXMucHVzaChwYXJzZWRUcmFuc2Zvcm1TdGVwLmpvaW4odHJhbnNmb3JtYXRpb25VdGlscy5nZXRUcmFuc2Zvcm1EZWxpbWl0ZXIoKSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWRUcmFuc2Zvcm1zLmpvaW4odHJhbnNmb3JtYXRpb25VdGlscy5nZXRDaGFpblRyYW5zZm9ybURlbGltaXRlcigpKTtcbn1cblxudmFyIHVybCA9IGZ1bmN0aW9uIHVybCh1cmxPcHRzLCBkZWZhdWx0T3B0aW9ucykge1xuICByZXR1cm4gYnVpbGRVUkwoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRPcHRpb25zKSwgdXJsT3B0cykpO1xufTtcblxuZnVuY3Rpb24gbWFuZGF0b3J5UGFyYW1ldGVyc0F2YWlsYWJsZShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnVybEVuZHBvaW50O1xufVxudmFyIHByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeSh0aGlzQ29udGV4dCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gZm4ubGVuZ3RoICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICAgIGZuLmNhbGwuYXBwbHkoZm4sIFt0aGlzQ29udGV4dF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3VsdHMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICByZXN1bHRzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzIDogcmVzdWx0c1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBmbi5jYWxsLmFwcGx5KGZuLCBbdGhpc0NvbnRleHRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xudmFyIEltYWdlS2l0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbWFnZUtpdChvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlS2l0KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgIHNka1ZlcnNpb246IFwiamF2YXNjcmlwdC1cIi5jb25jYXQodmVyc2lvbiksXG4gICAgICBwdWJsaWNLZXk6IFwiXCIsXG4gICAgICB1cmxFbmRwb2ludDogXCJcIixcbiAgICAgIHRyYW5zZm9ybWF0aW9uUG9zaXRpb246IHRyYW5zZm9ybWF0aW9uVXRpbHMuZ2V0RGVmYXVsdCgpXG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMub3B0aW9ucyksIG9wdHMgfHwge30pO1xuICAgIGlmICghbWFuZGF0b3J5UGFyYW1ldGVyc0F2YWlsYWJsZSh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBlcnJvck1lc3NhZ2VzLk1BTkRBVE9SWV9JTklUSUFMSVpBVElPTl9NSVNTSU5HO1xuICAgIH1cbiAgICBpZiAoIXRyYW5zZm9ybWF0aW9uVXRpbHMudmFsaWRQYXJhbWV0ZXJzKHRoaXMub3B0aW9ucykpIHtcbiAgICAgIHRocm93IGVycm9yTWVzc2FnZXMuSU5WQUxJRF9UUkFOU0ZPUk1BVElPTl9QT1NJVElPTjtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEltYWdlS2l0LCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXJsJDEodXJsT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHVybCh1cmxPcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkJDEodXBsb2FkT3B0aW9ucywgY2FsbGJhY2tPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tPck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja09yT3B0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBjYWxsYmFja09yT3B0aW9ucyB8fCB7fTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBsb2FkT3B0aW9ucyB8fCBfdHlwZW9mKHVwbG9hZE9wdGlvbnMpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiByZXNwb25kKHRydWUsIGVycm9yTWVzc2FnZXMuSU5WQUxJRF9VUExPQURfT1BUSU9OUywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICB2YXIgX3JlZiA9IHVwbG9hZE9wdGlvbnMgfHwge30sXG4gICAgICAgICAgdXNlclByb3ZpZGVkWEhSID0gX3JlZi54aHI7XG4gICAgICBkZWxldGUgdXBsb2FkT3B0aW9ucy54aHI7XG4gICAgICB2YXIgeGhyID0gdXNlclByb3ZpZGVkWEhSIHx8IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLCB1cGxvYWQpKHhociwgdXBsb2FkT3B0aW9ucywgbWVyZ2VkT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW1hZ2VLaXQ7XG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLy8gQ3JlYXRlIHRoZSBjb250ZXh0XG5jb25zdCBJbWFnZUtpdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbi8qKlxuICogUHJvdmlkZXMgYSBjb250YWluZXIgZm9yIEltYWdlS2l0IGNvbXBvbmVudHMuIEFueSBvcHRpb24gc2V0IGluIEltYWdlS2l0UHJvdmlkZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNoaWxkcmVuLlxuICpcbiAqIEBleGFtcGxlXG4gKjxJbWFnZUtpdFByb3ZpZGVyICBwdWJsaWNLZXk9XCI8cHVibGljIGtleT5cIiB1cmxFbmRwb2ludD1cInVybCBsaW5rXCI+XG4gKiAgICA8IS0tIG90aGVyIHRhZ3MgLS0+XG4gKiAgICA8SW1hZ2Ugc3JjPXtsaW5rfS8+XG4gKjwvSW1hZ2VLaXRQcm92aWRlcj5cbiAqL1xuY29uc3QgSW1hZ2VLaXRQcm92aWRlciA9IHByb3BzID0+IHtcbiAgY29uc3QgZXh0cmFjdENvbnRleHRPcHRpb25zID0gbWVyZ2VkT3B0aW9ucyA9PiB7XG4gICAgY29uc3QgcHJvcEtleXMgPSBbXCJwdWJsaWNLZXlcIiwgXCJ1cmxFbmRwb2ludFwiLCBcImF1dGhlbnRpY2F0b3JcIiwgXCJ0cmFuc2Zvcm1hdGlvblBvc2l0aW9uXCIsIFwiaWtDbGllbnRcIl07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVyZ2VkT3B0aW9ucykge1xuICAgICAgaWYgKCFwcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWRPcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xuICB9O1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpO1xuICBjb25zdCBjb250ZXh0T3B0aW9uc0V4dHJhY3RlZCA9IGV4dHJhY3RDb250ZXh0T3B0aW9ucyhtZXJnZWRPcHRpb25zKTtcbiAgaWYgKGNvbnRleHRPcHRpb25zRXh0cmFjdGVkLnVybEVuZHBvaW50ICYmIGNvbnRleHRPcHRpb25zRXh0cmFjdGVkLnVybEVuZHBvaW50LnRyaW0oKSAhPT0gXCJcIikge1xuICAgIGNvbnRleHRPcHRpb25zRXh0cmFjdGVkLmlrQ2xpZW50ID0gbmV3IEltYWdlS2l0KHtcbiAgICAgIHVybEVuZHBvaW50OiBjb250ZXh0T3B0aW9uc0V4dHJhY3RlZC51cmxFbmRwb2ludCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNka1ZlcnNpb246IFwiXCJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZUtpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dE9wdGlvbnNFeHRyYWN0ZWRcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufTtcblxuY29uc3QgdXNlSW1hZ2VLaXRDb21wb25lbnQgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGNvbnRleHRPcHRpb25zID0gdXNlQ29udGV4dChJbWFnZUtpdENvbnRleHQpO1xuICBjb25zdCBnZXRJS0NsaWVudCA9ICgpID0+IHtcbiAgICBpZiAoY29udGV4dE9wdGlvbnMgJiYgY29udGV4dE9wdGlvbnMuaWtDbGllbnQpIHtcbiAgICAgIHJldHVybiBjb250ZXh0T3B0aW9ucy5pa0NsaWVudDtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHVybEVuZHBvaW50XG4gICAgfSA9IHByb3BzO1xuICAgIHVybEVuZHBvaW50ID0gdXJsRW5kcG9pbnQgfHwgY29udGV4dE9wdGlvbnMgJiYgY29udGV4dE9wdGlvbnMudXJsRW5kcG9pbnQ7XG4gICAgaWYgKCF1cmxFbmRwb2ludCB8fCB1cmxFbmRwb2ludC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdXJsRW5kcG9pbnQgZHVyaW5nIGluaXRpYWxpemF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBpa0NsaWVudCA9IG5ldyBJbWFnZUtpdCh7XG4gICAgICB1cmxFbmRwb2ludDogdXJsRW5kcG9pbnQsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZGtWZXJzaW9uOiBcIlwiXG4gICAgfSk7XG4gICAgcmV0dXJuIGlrQ2xpZW50O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGdldElLQ2xpZW50XG4gIH07XG59O1xuXG5jb25zdCBmZXRjaEVmZmVjdGl2ZUNvbm5lY3Rpb24gPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5jb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGU7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIFwiNGdcIjtcbiAgfVxufTtcbmNvbnN0IGdldFNyYyA9ICh7XG4gIHVybEVuZHBvaW50LFxuICBscWlwLFxuICBzcmMsXG4gIHBhdGgsXG4gIHRyYW5zZm9ybWF0aW9uLFxuICB0cmFuc2Zvcm1hdGlvblBvc2l0aW9uLFxuICBxdWVyeVBhcmFtZXRlcnNcbn0sIGlrQ2xpZW50LCBjb250ZXh0T3B0aW9ucykgPT4ge1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKHNyYykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB1cmxFbmRwb2ludDogdXJsRW5kcG9pbnQgfHwgY29udGV4dE9wdGlvbnMudXJsRW5kcG9pbnQsXG4gICAgICBzcmMsXG4gICAgICB0cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb24gfHwgdW5kZWZpbmVkLFxuICAgICAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvbjogdHJhbnNmb3JtYXRpb25Qb3NpdGlvbiB8fCBjb250ZXh0T3B0aW9ucy50cmFuc2Zvcm1hdGlvblBvc2l0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIHF1ZXJ5UGFyYW1ldGVyczogcXVlcnlQYXJhbWV0ZXJzIHx8IHt9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVybEVuZHBvaW50OiB1cmxFbmRwb2ludCB8fCBjb250ZXh0T3B0aW9ucy51cmxFbmRwb2ludCxcbiAgICAgIHBhdGgsXG4gICAgICB0cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb24gfHwgdW5kZWZpbmVkLFxuICAgICAgdHJhbnNmb3JtYXRpb25Qb3NpdGlvbjogdHJhbnNmb3JtYXRpb25Qb3NpdGlvbiB8fCBjb250ZXh0T3B0aW9ucy50cmFuc2Zvcm1hdGlvblBvc2l0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIHF1ZXJ5UGFyYW1ldGVyczogcXVlcnlQYXJhbWV0ZXJzIHx8IHt9XG4gICAgfTtcbiAgfSBlbHNlIHJldHVybiB7XG4gICAgb3JpZ2luYWxTcmM6IFwiXCJcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9yaWdpbmFsU3JjOiBpa0NsaWVudC51cmwob3B0aW9ucylcbiAgfTtcbiAgaWYgKGxxaXAgJiYgbHFpcC5hY3RpdmUpIHtcbiAgICB2YXIgcXVhbGl0eSA9IE1hdGgucm91bmQobHFpcC5xdWFsaXR5IHx8IGxxaXAudGhyZXNob2xkIHx8IDIwKTtcbiAgICB2YXIgYmx1ciA9IE1hdGgucm91bmQobHFpcC5ibHVyIHx8IDYpO1xuICAgIHZhciBuZXdUcmFuc2Zvcm1hdGlvbiA9IG9wdGlvbnMudHJhbnNmb3JtYXRpb24gPyBbLi4ub3B0aW9ucy50cmFuc2Zvcm1hdGlvbl0gOiBbXTtcbiAgICBpZiAobHFpcC5yYXcgJiYgdHlwZW9mIGxxaXAucmF3ID09PSBcInN0cmluZ1wiICYmIGxxaXAucmF3LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgbmV3VHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICAgIHJhdzogbHFpcC5yYXcudHJpbSgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3VHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICAgIHF1YWxpdHk6IFN0cmluZyhxdWFsaXR5KSxcbiAgICAgICAgYmx1cjogU3RyaW5nKGJsdXIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0LmxxaXBTcmMgPSBpa0NsaWVudC51cmwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHJhbnNmb3JtYXRpb246IG5ld1RyYW5zZm9ybWF0aW9uXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZ2V0SUtFbGVtZW50c1VybCA9ICh7XG4gIGxxaXAgPSBudWxsLFxuICBsb2FkaW5nXG59LCB7XG4gIGludGVyc2VjdGVkLFxuICBvcmlnaW5hbFNyY0xvYWRlZCxcbiAgb3JpZ2luYWxTcmMsXG4gIGxxaXBTcmNcbn0pID0+IHtcbiAgLypcbiAgICAgIE5vIGxhenkgbG9hZGluZyBubyBscWlwXG4gICAgICAgIHNyYz1vcmlnaW5hbEltYWdlXG4gICAgICBObyBsYXp5IGxvYWRpbmcgbHFpcFxuICAgICAgICBzcmM9bHFpcFxuICAgICAgICBzcmM9b3JpZ2luYWxJbWFnZSAod2hlbiBsb2FkZWQpXG4gICAgICBsYXp5IGxvYWRpbmcgYW5kIG5vIGxxaXBcbiAgICAgICAgc3JjPScnXG4gICAgICAgIG9uSW50ZXJzZWN0OlxuICAgICAgICBzcmM9b3JpZ2luYWxJbWFnZVxuICAgICAgbGF6eSBsb2FkaW5nIGFuZCBscWlwXG4gICAgICAgIHNyYz1scWlwXG4gICAgICAgIG9uSW50ZXJzZWN0OlxuICAgICAgICBzcmM9b3JpZ2luYWxJbWFnZSAod2hlbiBsb2FkZWQpXG4gICAgKi9cbiAgY29uc3QgaXNMcWlwQWN0aXZlID0gbHFpcCA9PiBscWlwICYmIGxxaXAuYWN0aXZlO1xuICBpZiAobG9hZGluZyAhPT0gXCJsYXp5XCIgJiYgIWlzTHFpcEFjdGl2ZShscWlwKSkge1xuICAgIHJldHVybiBvcmlnaW5hbFNyYztcbiAgfSBlbHNlIGlmIChsb2FkaW5nICE9PSBcImxhenlcIiAmJiBpc0xxaXBBY3RpdmUobHFpcCkpIHtcbiAgICBpZiAob3JpZ2luYWxTcmNMb2FkZWQpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxxaXBTcmM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxvYWRpbmcgPT09IFwibGF6eVwiICYmICFpc0xxaXBBY3RpdmUobHFpcCkpIHtcbiAgICBpZiAoaW50ZXJzZWN0ZWQpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpbnRlcnNlY3RlZCAmJiBvcmlnaW5hbFNyY0xvYWRlZCkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsU3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbHFpcFNyYztcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShhcnJheSwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGFycmF5LnNvbWUob2JqID0+IG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpO1xufVxuY29uc3QgdXBkYXRlVHJhbnNmb3JtYXRpb24gPSAoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICB0cmFuc2Zvcm1hdGlvbixcbiAgc3JjLFxuICBwYXRoLFxuICBxdWFsaXR5XG59KSA9PiB7XG4gIC8vaWYgaGVpZ2h0IGFuZCB3aWR0aCBhcmUgdGhlcmUgaW4gcHJvcHMgYW5kIGFic2VudCBpbiB0cmFuc2Zvcm1hdGlvbiB0aGVuIGFkZCBpdCB0byB0aGUgdHJhbnNmb3JtYXRpaW9uXG4gIGlmICgoc3JjIHx8IHBhdGgpICYmICh3aWR0aCB8fCBxdWFsaXR5IHx8IGhlaWdodCkpIHtcbiAgICBsZXQgdHJhbnNmb3JtYXRpb25PYmplY3QgPSB7fTtcbiAgICBpZiAoISgodHJhbnNmb3JtYXRpb24gPT09IG51bGwgfHwgdHJhbnNmb3JtYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWF0aW9uLmxlbmd0aCkgJiYgKGhhc1Byb3BlcnR5KHRyYW5zZm9ybWF0aW9uLCBcImhlaWdodFwiKSB8fCBoYXNQcm9wZXJ0eSh0cmFuc2Zvcm1hdGlvbiwgXCJ3aWR0aFwiKSkpKSB7XG4gICAgICBpZiAoaGVpZ2h0KSB0cmFuc2Zvcm1hdGlvbk9iamVjdFtcImhlaWdodFwiXSA9IFN0cmluZyhoZWlnaHQpO1xuICAgICAgaWYgKHdpZHRoKSB0cmFuc2Zvcm1hdGlvbk9iamVjdFtcIndpZHRoXCJdID0gU3RyaW5nKHdpZHRoKTtcbiAgICB9XG4gICAgaWYgKCEoKHRyYW5zZm9ybWF0aW9uID09PSBudWxsIHx8IHRyYW5zZm9ybWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1hdGlvbi5sZW5ndGgpICYmIGhhc1Byb3BlcnR5KHRyYW5zZm9ybWF0aW9uLCBcInF1YWxpdHlcIikpICYmIHF1YWxpdHkpIHRyYW5zZm9ybWF0aW9uT2JqZWN0W1wicXVhbGl0eVwiXSA9IFN0cmluZyhxdWFsaXR5KTtcbiAgICBpZiAoT2JqZWN0LmtleXModHJhbnNmb3JtYXRpb25PYmplY3QpLmxlbmd0aCkge1xuICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uID09PSBudWxsIHx8IHRyYW5zZm9ybWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1hdGlvbi5sZW5ndGgpIHRyYW5zZm9ybWF0aW9uID0gWy4uLnRyYW5zZm9ybWF0aW9uLCB0cmFuc2Zvcm1hdGlvbk9iamVjdF07ZWxzZSB0cmFuc2Zvcm1hdGlvbiA9IFt0cmFuc2Zvcm1hdGlvbk9iamVjdF07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbjtcbn07XG5cbmNvbnN0IElLSW1hZ2UgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IFtjdXJyZW50VXJsLCBzZXRDdXJyZW50VXJsXSA9IHVzZVN0YXRlKHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtpbWFnZVByb3BzLCBzZXRJbWFnZVByb3BzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW29yaWdpbmFsU3JjLCBzZXRPcmlnaW5hbFNyY10gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2xxaXBTcmMsIHNldExxaXBTcmNdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtvcmlnaW5hbFNyY0xvYWRlZCwgc2V0T3JpZ2luYWxTcmNMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbb2JzZXJ2ZSwgc2V0T2JzZXJ2ZV0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xuICBjb25zdCBbaW5pdGlhbGl6ZWQsIHNldEluaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ludGVyc2VjdGVkLCBzZXRJbnRlcnNlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgZ2V0SUtDbGllbnRcbiAgfSA9IHVzZUltYWdlS2l0Q29tcG9uZW50KE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSk7XG4gIGNvbnN0IGNvbnRleHRPcHRpb25zID0gdXNlQ29udGV4dChJbWFnZUtpdENvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9yaWdpbmFsU3JjOiBuZXdPcmlnaW5hbFNyYyxcbiAgICAgIGxxaXBTcmM6IG5ld0xxaXBTcmNcbiAgICB9ID0gZ2V0U3JjKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbjogdXBkYXRlVHJhbnNmb3JtYXRpb24ocHJvcHMpXG4gICAgfSksIGdldElLQ2xpZW50KCksIGNvbnRleHRPcHRpb25zKTtcbiAgICBzZXRPcmlnaW5hbFNyYyhuZXdPcmlnaW5hbFNyYyk7XG4gICAgc2V0THFpcFNyYyhuZXdMcWlwU3JjID8gbmV3THFpcFNyYyA6IFwiXCIpO1xuICAgIHNldEluaXRpYWxpemVkKHRydWUpO1xuICB9LCBbY29udGV4dE9wdGlvbnMsIHByb3BzXSk7XG4gIGNvbnN0IHVwZGF0ZUltYWdlVXJsID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdXJsID0geWllbGQgZ2V0SUtFbGVtZW50c1VybChwcm9wcywge1xuICAgICAgb3JpZ2luYWxTcmMsXG4gICAgICBscWlwU3JjLFxuICAgICAgaW50ZXJzZWN0ZWQsXG4gICAgICBjb250ZXh0T3B0aW9ucyxcbiAgICAgIGluaXRpYWx6ZVN0YXRlOiBpbml0aWFsaXplZCxcbiAgICAgIG9yaWdpbmFsU3JjTG9hZGVkLFxuICAgICAgb2JzZXJ2ZVxuICAgIH0pOyAvLyBJbmNsdWRlIGludGVyc2VjdGVkIHN0YXRlXG4gICAgaWYgKHVybCkge1xuICAgICAgc2V0Q3VycmVudFVybCh1cmwpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRyaWdnZXJPcmlnaW5hbEltYWdlTG9hZCA9ICgpID0+IHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHNldE9yaWdpbmFsU3JjTG9hZGVkKHRydWUpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IG9yaWdpbmFsU3JjO1xuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvcmlnaW5hbFNyY0xvYWRlZCkgdXBkYXRlSW1hZ2VVcmwoKTtcbiAgfSwgW29yaWdpbmFsU3JjTG9hZGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW1hZ2UgPSBpbWFnZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdcbiAgICB9ID0gcHJvcHM7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICBpZiAod2luZG93ICYmIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIiBpbiB3aW5kb3cgJiYgbG9hZGluZyA9PT0gXCJsYXp5XCIgJiYgbHFpcCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uVHlwZSA9IGZldGNoRWZmZWN0aXZlQ29ubmVjdGlvbigpO1xuICAgICAgICBsZXQgcm9vdE1hcmdpbiA9IFwiMTI1MHB4XCI7XG4gICAgICAgIGlmIChjb25uZWN0aW9uVHlwZSAhPT0gXCI0Z1wiKSByb290TWFyZ2luID0gXCIyNTAwcHhcIjtcbiAgICAgICAgY29uc3QgaW1hZ2VPYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICBjb25zdCBlbCA9IGVudHJpZXNbMF07XG4gICAgICAgICAgaWYgKGVsICYmIGVsLmlzSW50ZXJzZWN0aW5nICYmICFpbnRlcnNlY3RlZCkge1xuICAgICAgICAgICAgc2V0SW50ZXJzZWN0ZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRPYnNlcnZlKHByZXZPYnNlcnZlciA9PiB7XG4gICAgICAgICAgICAgIGlmIChwcmV2T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJPcmlnaW5hbEltYWdlTG9hZCgpO1xuICAgICAgICAgICAgdXBkYXRlSW1hZ2VVcmwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICByb290TWFyZ2luOiBgJHtyb290TWFyZ2lufSAwcHggJHtyb290TWFyZ2lufSAwcHhgXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICBpbWFnZU9ic2VydmVyLm9ic2VydmUoaW1hZ2UpO1xuICAgICAgICAgIHNldE9ic2VydmUoaW1hZ2VPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEludGVyc2VjdGVkKHRydWUpO1xuICAgICAgICB0cmlnZ2VyT3JpZ2luYWxJbWFnZUxvYWQoKTtcbiAgICAgICAgdXBkYXRlSW1hZ2VVcmwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChvYnNlcnZlKSB7XG4gICAgICAgIG9ic2VydmUuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtwcm9wcywgb3JpZ2luYWxTcmMsIGxxaXBTcmNdKTtcbiAgY29uc3Qge1xuICAgICAgdXJsRW5kcG9pbnQsXG4gICAgICBhdXRoZW50aWNhdG9yLFxuICAgICAgcHVibGljS2V5LFxuICAgICAgbG9hZGluZyxcbiAgICAgIGxxaXAsXG4gICAgICBwYXRoLFxuICAgICAgc3JjLFxuICAgICAgdHJhbnNmb3JtYXRpb24sXG4gICAgICB0cmFuc2Zvcm1hdGlvblBvc2l0aW9uLFxuICAgICAgcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgYWx0XG4gICAgfSA9IHByb3BzLFxuICAgIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1widXJsRW5kcG9pbnRcIiwgXCJhdXRoZW50aWNhdG9yXCIsIFwicHVibGljS2V5XCIsIFwibG9hZGluZ1wiLCBcImxxaXBcIiwgXCJwYXRoXCIsIFwic3JjXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ0cmFuc2Zvcm1hdGlvblBvc2l0aW9uXCIsIFwicXVlcnlQYXJhbWV0ZXJzXCIsIFwiYWx0XCJdKTtcbiAgY29uc3QgcmVzdFByb3BzV2l0aG91dEltYWdlUHJvcHMgPSBfX3Jlc3QocmVzdFByb3BzLCBbXCJmaWxsXCIsIFwicXVhbGl0eVwiLCBcInByaW9yaXR5XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJibHVyRGF0YVVSTFwiLCBcInVub3B0aW1pemVkXCIsIFwib3ZlcnJpZGVTcmNcIiwgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLCBcImxheW91dFwiLCBcIm9iamVjdEZpdFwiLCBcIm9iamVjdFBvc2l0aW9uXCIsIFwibGF6eUJvdW5kYXJ5XCIsIFwibGF6eVJvb3RcIl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIGlmIGhlaWdodCBhbmQgd2lkdGggYXJlIHRoZXJlIGluIHRyYW5zZm9ybWF0aW9uIHNraXAgcHJvcHMgaGVpZ2h0IGFuZCB3aWR0aCBhbmQgYWRkIGZpbGwgPXRydWVcbiAgICBjb25zdCB1cGRhdGVkUmVzdFByb3BzID0gcmVzdFByb3BzO1xuICAgIGlmICgodHJhbnNmb3JtYXRpb24gPT09IG51bGwgfHwgdHJhbnNmb3JtYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWF0aW9uLmxlbmd0aCkgJiYgdHJhbnNmb3JtYXRpb24uc29tZShvYmogPT4gb2JqLmhhc093blByb3BlcnR5KFwiaGVpZ2h0XCIpIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShcIndpZHRoXCIpKSkge1xuICAgICAgaWYgKHVwZGF0ZWRSZXN0UHJvcHMuaGVpZ2h0KSBkZWxldGUgdXBkYXRlZFJlc3RQcm9wc1tcImhlaWdodFwiXTtcbiAgICAgIGlmICh1cGRhdGVkUmVzdFByb3BzLndpZHRoKSBkZWxldGUgdXBkYXRlZFJlc3RQcm9wc1tcIndpZHRoXCJdO1xuICAgICAgdXBkYXRlZFJlc3RQcm9wc1tcImZpbGxcIl0gPSB0cnVlO1xuICAgIH1cbiAgICBzZXRJbWFnZVByb3BzKHVwZGF0ZWRSZXN0UHJvcHMpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxxaXAgPT09IG51bGwgfHwgbHFpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbHFpcC5hY3RpdmUpIGNvbnNvbGUud2FybihcIkluIFtpbWFnZWtpdGlvLW5leHRdLCBsb2FkaW5nIGlzIHNldCB0byBlYWdlciB3aGVuIExRSVAgaXMgdXNlZC5cIik7XG4gIH0sIFtscWlwXSk7XG4gIHJldHVybiBjdXJyZW50VXJsICE9IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhpbWFnZVByb3BzKS5sZW5ndGggPyBSZWFjdC5jcmVhdGVFbGVtZW50KE5leHRJbWFnZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgbG9hZGVyOiAoe1xuICAgICAgc3JjXG4gICAgfSkgPT4gc3JjLFxuICAgIGFsdDogYWx0LFxuICAgIHNyYzogY3VycmVudFVybCA/IGN1cnJlbnRVcmwgOiBcIlwiLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgdW5vcHRpbWl6ZWQ6IHRydWUsXG4gICAgbG9hZGluZzogKGxxaXAgPT09IG51bGwgfHwgbHFpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbHFpcC5hY3RpdmUpID8gXCJlYWdlclwiIDogbG9hZGluZ1xuICB9LCBpbWFnZVByb3BzKSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHNyYzogY3VycmVudFVybCA/IGN1cnJlbnRVcmwgOiB1bmRlZmluZWQsXG4gICAgcmVmOiBpbWFnZVJlZlxuICB9LCByZXN0UHJvcHNXaXRob3V0SW1hZ2VQcm9wcykpO1xufTtcblxuY29uc3QgSUtVcGxvYWQgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHVzZUNvbnRleHQoSW1hZ2VLaXRDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIGdldElLQ2xpZW50XG4gIH0gPSB1c2VJbWFnZUtpdENvbXBvbmVudChPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnhocikge1xuICAgICAgICBzdGF0ZS54aHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZWYgJiYgdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJiByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpKSB7XG4gICAgICBjb25zdCByZWZPYmplY3QgPSByZWY7XG4gICAgICByZWZPYmplY3QuY3VycmVudC5hYm9ydCA9IGFib3J0O1xuICAgIH1cbiAgfSwgW3N0YXRlLnhociwgcmVmXSk7XG4gIGNvbnN0IHtcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHVybEVuZHBvaW50LFxuICAgICAgYXV0aGVudGljYXRvcixcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgdXNlVW5pcXVlRmlsZU5hbWUsXG4gICAgICB0YWdzLFxuICAgICAgZm9sZGVyLFxuICAgICAgaXNQcml2YXRlRmlsZSxcbiAgICAgIGN1c3RvbUNvb3JkaW5hdGVzLFxuICAgICAgcmVzcG9uc2VGaWVsZHMsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25TdWNjZXNzLFxuICAgICAgb25VcGxvYWRTdGFydCxcbiAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICB2YWxpZGF0ZUZpbGUsXG4gICAgICB3ZWJob29rVXJsLFxuICAgICAgb3ZlcndyaXRlRmlsZSxcbiAgICAgIG92ZXJ3cml0ZUFJVGFncyxcbiAgICAgIG92ZXJ3cml0ZVRhZ3MsXG4gICAgICBvdmVyd3JpdGVDdXN0b21NZXRhZGF0YSxcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICBjdXN0b21NZXRhZGF0YSxcbiAgICAgIHRyYW5zZm9ybWF0aW9uLFxuICAgICAgb3ZlcnJpZGVQYXJhbWV0ZXJzLFxuICAgICAgY2hlY2tzXG4gICAgfSA9IHByb3BzLFxuICAgIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wicHVibGljS2V5XCIsIFwidXJsRW5kcG9pbnRcIiwgXCJhdXRoZW50aWNhdG9yXCIsIFwiZmlsZU5hbWVcIiwgXCJ1c2VVbmlxdWVGaWxlTmFtZVwiLCBcInRhZ3NcIiwgXCJmb2xkZXJcIiwgXCJpc1ByaXZhdGVGaWxlXCIsIFwiY3VzdG9tQ29vcmRpbmF0ZXNcIiwgXCJyZXNwb25zZUZpZWxkc1wiLCBcIm9uRXJyb3JcIiwgXCJvblN1Y2Nlc3NcIiwgXCJvblVwbG9hZFN0YXJ0XCIsIFwib25VcGxvYWRQcm9ncmVzc1wiLCBcInZhbGlkYXRlRmlsZVwiLCBcIndlYmhvb2tVcmxcIiwgXCJvdmVyd3JpdGVGaWxlXCIsIFwib3ZlcndyaXRlQUlUYWdzXCIsIFwib3ZlcndyaXRlVGFnc1wiLCBcIm92ZXJ3cml0ZUN1c3RvbU1ldGFkYXRhXCIsIFwiZXh0ZW5zaW9uc1wiLCBcImN1c3RvbU1ldGFkYXRhXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJvdmVycmlkZVBhcmFtZXRlcnNcIiwgXCJjaGVja3NcIl0pO1xuICBjb25zdCB1cGxvYWRGaWxlID0gZSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHByb3BzLnB1YmxpY0tleSB8fCBjb250ZXh0T3B0aW9ucy5wdWJsaWNLZXk7XG4gICAgY29uc3QgYXV0aGVudGljYXRvciA9IHByb3BzLmF1dGhlbnRpY2F0b3IgfHwgY29udGV4dE9wdGlvbnMuYXV0aGVudGljYXRvcjtcbiAgICBjb25zdCB1cmxFbmRwb2ludCA9IHByb3BzLnVybEVuZHBvaW50IHx8IGNvbnRleHRPcHRpb25zLnVybEVuZHBvaW50O1xuICAgIGlmICghcHVibGljS2V5IHx8IHB1YmxpY0tleS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIGlmIChvbkVycm9yICYmIHR5cGVvZiBvbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb25FcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIHB1YmxpY0tleVwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWF1dGhlbnRpY2F0b3IpIHtcbiAgICAgIGlmIChvbkVycm9yICYmIHR5cGVvZiBvbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb25FcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJUaGUgYXV0aGVudGljYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXV0aGVudGljYXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVkIGF1dGhlbnRpY2F0b3IgaXMgbm90IGEgZnVuY3Rpb24uXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdXJsRW5kcG9pbnQgfHwgdXJsRW5kcG9pbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyB1cmxFbmRwb2ludFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWtDbGllbnQgPSBnZXRJS0NsaWVudCgpO1xuICAgIGNvbnN0IGZpbGUgPSAoX2EgPSBlLnRhcmdldC5maWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgIGlmICghZmlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsaWRhdGVGaWxlICYmICFwcm9wcy52YWxpZGF0ZUZpbGUoZmlsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uVXBsb2FkU3RhcnQgJiYgdHlwZW9mIHByb3BzLm9uVXBsb2FkU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcHJvcHMub25VcGxvYWRTdGFydChlKTtcbiAgICB9XG4gICAgbGV0IG92ZXJyaWRlVmFsdWVzID0ge307XG4gICAgaWYgKHByb3BzLm92ZXJyaWRlUGFyYW1ldGVycyAmJiB0eXBlb2YgcHJvcHMub3ZlcnJpZGVQYXJhbWV0ZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG92ZXJyaWRlVmFsdWVzID0gcHJvcHMub3ZlcnJpZGVQYXJhbWV0ZXJzKGZpbGUpIHx8IHt9O1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBwcm9ncmVzc0NiID0gZSA9PiB7XG4gICAgICBpZiAocHJvcHMub25VcGxvYWRQcm9ncmVzcyAmJiB0eXBlb2YgcHJvcHMub25VcGxvYWRQcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHByb3BzLm9uVXBsb2FkUHJvZ3Jlc3MoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBwcm9ncmVzc0NiKTtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgZmlsZTogZmlsZSxcbiAgICAgIGZpbGVOYW1lOiBvdmVycmlkZVZhbHVlcy5maWxlTmFtZSB8fCBmaWxlTmFtZSB8fCBmaWxlLm5hbWUsXG4gICAgICB1c2VVbmlxdWVGaWxlTmFtZTogb3ZlcnJpZGVWYWx1ZXMudXNlVW5pcXVlRmlsZU5hbWUgfHwgdXNlVW5pcXVlRmlsZU5hbWUsXG4gICAgICB0YWdzOiBvdmVycmlkZVZhbHVlcy50YWdzIHx8IHRhZ3MsXG4gICAgICBmb2xkZXI6IG92ZXJyaWRlVmFsdWVzLmZvbGRlciB8fCBmb2xkZXIsXG4gICAgICBpc1ByaXZhdGVGaWxlOiBvdmVycmlkZVZhbHVlcy5pc1ByaXZhdGVGaWxlIHx8IGlzUHJpdmF0ZUZpbGUsXG4gICAgICBjdXN0b21Db29yZGluYXRlczogb3ZlcnJpZGVWYWx1ZXMuY3VzdG9tQ29vcmRpbmF0ZXMgfHwgY3VzdG9tQ29vcmRpbmF0ZXMsXG4gICAgICByZXNwb25zZUZpZWxkcyxcbiAgICAgIGV4dGVuc2lvbnM6IG92ZXJyaWRlVmFsdWVzLmV4dGVuc2lvbnMgfHwgZXh0ZW5zaW9ucyxcbiAgICAgIHdlYmhvb2tVcmw6IG92ZXJyaWRlVmFsdWVzLndlYmhvb2tVcmwgfHwgd2ViaG9va1VybCxcbiAgICAgIG92ZXJ3cml0ZUZpbGU6IG92ZXJyaWRlVmFsdWVzLm92ZXJ3cml0ZUZpbGUgfHwgb3ZlcndyaXRlRmlsZSxcbiAgICAgIG92ZXJ3cml0ZUFJVGFnczogb3ZlcnJpZGVWYWx1ZXMub3ZlcndyaXRlQUlUYWdzIHx8IG92ZXJ3cml0ZUFJVGFncyxcbiAgICAgIG92ZXJ3cml0ZVRhZ3M6IG92ZXJyaWRlVmFsdWVzLm92ZXJ3cml0ZVRhZ3MgfHwgb3ZlcndyaXRlVGFncyxcbiAgICAgIG92ZXJ3cml0ZUN1c3RvbU1ldGFkYXRhOiBvdmVycmlkZVZhbHVlcy5vdmVyd3JpdGVDdXN0b21NZXRhZGF0YSB8fCBvdmVyd3JpdGVDdXN0b21NZXRhZGF0YSxcbiAgICAgIGN1c3RvbU1ldGFkYXRhOiBvdmVycmlkZVZhbHVlcy5jdXN0b21NZXRhZGF0YSB8fCBjdXN0b21NZXRhZGF0YSxcbiAgICAgIHNpZ25hdHVyZTogXCJcIixcbiAgICAgIGV4cGlyZTogMCxcbiAgICAgIHRva2VuOiBcIlwiLFxuICAgICAgeGhyLFxuICAgICAgdHJhbnNmb3JtYXRpb246IG92ZXJyaWRlVmFsdWVzLnRyYW5zZm9ybWF0aW9uIHx8IHRyYW5zZm9ybWF0aW9uLFxuICAgICAgY2hlY2tzOiBvdmVycmlkZVZhbHVlcy5jaGVja3MgfHwgY2hlY2tzXG4gICAgfTtcbiAgICBjb25zdCBhdXRoUHJvbWlzZSA9IGF1dGhlbnRpY2F0b3IoKTtcbiAgICBpZiAoIShhdXRoUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9uRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiVGhlIGF1dGhlbnRpY2F0b3IgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSBpbnN0YW5jZS5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXV0aFByb21pc2UudGhlbigoe1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgdG9rZW4sXG4gICAgICBleHBpcmVcbiAgICB9KSA9PiB7XG4gICAgICBwYXJhbXNbXCJzaWduYXR1cmVcIl0gPSBzaWduYXR1cmU7XG4gICAgICBwYXJhbXNbXCJleHBpcmVcIl0gPSBleHBpcmU7XG4gICAgICBwYXJhbXNbXCJ0b2tlblwiXSA9IHRva2VuO1xuICAgICAgaWtDbGllbnQudXBsb2FkKHBhcmFtcywgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgdHlwZW9mIG9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnVwbG9hZC5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcHJvZ3Jlc3NDYik7XG4gICAgICB9LCB7XG4gICAgICAgIHB1YmxpY0tleVxuICAgICAgfSk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHhoclxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZGF0YSA9PiB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVycm9yID0gZGF0YVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVycm9yICYmIHR5cGVvZiBvbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb25FcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogU3RyaW5nKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBPYmplY3QuYXNzaWduKHt9LCByZXN0UHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICB0eXBlOiBcImZpbGVcIixcbiAgICBvbkNoYW5nZTogZSA9PiB7XG4gICAgICBpZiAocHJvcHMub25DaGFuZ2UgJiYgdHlwZW9mIHByb3BzLm9uQ2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UoZSk7XG4gICAgICB9XG4gICAgICB1cGxvYWRGaWxlKGUpO1xuICAgIH1cbiAgfSkpO1xufSk7XG5cbmNvbnN0IElLVmlkZW8gPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKHtcbiAgICBjdXJyZW50VXJsOiBcIlwiLFxuICAgIGNvbnRleHRPcHRpb25zOiB7fVxuICB9KTtcbiAgY29uc3Qge1xuICAgIGdldElLQ2xpZW50XG4gIH0gPSB1c2VJbWFnZUtpdENvbXBvbmVudChPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpO1xuICBjb25zdCBjb250ZXh0SXRlbXMgPSB1c2VDb250ZXh0KEltYWdlS2l0Q29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luYWxTcmNcbiAgICB9ID0gZ2V0U3JjKHByb3BzLCBnZXRJS0NsaWVudCgpLCBjb250ZXh0SXRlbXMpO1xuICAgIHNldFN0YXRlKHByZXZTdGF0ZSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXZTdGF0ZSksIHtcbiAgICAgIGN1cnJlbnRVcmw6IG9yaWdpbmFsU3JjLFxuICAgICAgY29udGV4dE9wdGlvbnM6IGNvbnRleHRJdGVtc1xuICAgIH0pKTtcbiAgfSwgW2NvbnRleHRJdGVtcywgcHJvcHNdKTtcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRVcmxcbiAgfSA9IHN0YXRlO1xuICBjb25zdCByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInVybEVuZHBvaW50XCIsIFwicHVibGljS2V5XCIsIFwiYXV0aGVudGljYXRvclwiLCBcInBhdGhcIiwgXCJzcmNcIiwgXCJ0cmFuc2Zvcm1hdGlvblwiLCBcInRyYW5zZm9ybWF0aW9uUG9zaXRpb25cIiwgXCJxdWVyeVBhcmFtZXRlcnNcIl0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInZpZGVvXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcywge1xuICAgIHJlZjogdmlkZW9SZWYsXG4gICAga2V5OiBjdXJyZW50VXJsXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIsIHtcbiAgICBzcmM6IGN1cnJlbnRVcmwgfHwgdW5kZWZpbmVkLFxuICAgIHR5cGU6IFwidmlkZW8vbXA0XCJcbiAgfSkpO1xufTtcblxuZXhwb3J0IHsgSUtJbWFnZSwgSUtVcGxvYWQsIElLVmlkZW8sIEltYWdlS2l0IGFzIEltYWdlS2l0Q2xpZW50LCBJbWFnZUtpdENvbnRleHQsIEltYWdlS2l0UHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdla2l0LW5leHQuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/imagekitio-next/dist/imagekit-next.esm.js\n");

/***/ })

};
;